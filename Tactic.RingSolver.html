<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>Tactic.RingSolver</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">------------------------------------------------------------------------</a>
<a id="74" class="Comment">-- The Agda standard library</a>
<a id="103" class="Comment">--</a>
<a id="106" class="Comment">-- A solver that uses reflection to automatically obtain and solve</a>
<a id="173" class="Comment">-- equations over rings.</a>
<a id="198" class="Comment">------------------------------------------------------------------------</a>

<a id="272" class="Symbol">{-#</a> <a id="276" class="Keyword">OPTIONS</a> <a id="284" class="Pragma">--without-K</a> <a id="296" class="Pragma">--safe</a> <a id="303" class="Symbol">#-}</a>

<a id="308" class="Keyword">module</a> <a id="315" href="Tactic.RingSolver.html" class="Module">Tactic.RingSolver</a> <a id="333" class="Keyword">where</a>

<a id="340" class="Keyword">open</a> <a id="345" class="Keyword">import</a> <a id="352" href="Algebra.html" class="Module">Algebra</a>
<a id="360" class="Keyword">open</a> <a id="365" class="Keyword">import</a> <a id="372" href="Data.Fin.Base.html" class="Module">Data.Fin.Base</a>   <a id="388" class="Symbol">as</a> <a id="391" class="Module">Fin</a>     <a id="399" class="Keyword">using</a> <a id="405" class="Symbol">(</a><a id="406" href="Data.Fin.Base.html#1203" class="Datatype">Fin</a><a id="409" class="Symbol">)</a>
<a id="411" class="Keyword">open</a> <a id="416" class="Keyword">import</a> <a id="423" href="Data.Vec.Base.html" class="Module">Data.Vec.Base</a>   <a id="439" class="Symbol">as</a> <a id="442" class="Module">Vec</a>     <a id="450" class="Keyword">using</a> <a id="456" class="Symbol">(</a><a id="457" href="Data.Vec.Base.html#1051" class="Datatype">Vec</a><a id="460" class="Symbol">;</a> <a id="462" href="Data.Vec.Base.html#1106" class="InductiveConstructor Operator">_∷_</a><a id="465" class="Symbol">;</a> <a id="467" href="Data.Vec.Base.html#1087" class="InductiveConstructor">[]</a><a id="469" class="Symbol">)</a>
<a id="471" class="Keyword">open</a> <a id="476" class="Keyword">import</a> <a id="483" href="Data.List.Base.html" class="Module">Data.List.Base</a>  <a id="499" class="Symbol">as</a> <a id="502" class="Module">List</a>    <a id="510" class="Keyword">using</a> <a id="516" class="Symbol">(</a><a id="517" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="521" class="Symbol">;</a> <a id="523" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="526" class="Symbol">;</a> <a id="528" href="Data.List.Base.html#7182" class="InductiveConstructor">[]</a><a id="530" class="Symbol">)</a>
<a id="532" class="Keyword">open</a> <a id="537" class="Keyword">import</a> <a id="544" href="Data.Maybe.Base.html" class="Module">Data.Maybe.Base</a> <a id="560" class="Symbol">as</a> <a id="563" class="Module">Maybe</a>   <a id="571" class="Keyword">using</a> <a id="577" class="Symbol">(</a><a id="578" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="583" class="Symbol">;</a> <a id="585" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a><a id="589" class="Symbol">;</a> <a id="591" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a><a id="598" class="Symbol">;</a> <a id="600" href="Data.Maybe.Base.html#1632" class="Function">fromMaybe</a><a id="609" class="Symbol">)</a>
<a id="611" class="Keyword">open</a> <a id="616" class="Keyword">import</a> <a id="623" href="Data.Nat.Base.html" class="Module">Data.Nat.Base</a>              <a id="650" class="Keyword">using</a> <a id="656" class="Symbol">(</a><a id="657" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="658" class="Symbol">;</a> <a id="660" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="663" class="Symbol">;</a> <a id="665" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="669" class="Symbol">;</a> <a id="671" href="Data.Nat.Base.html#1230" class="Primitive Operator">_&lt;ᵇ_</a><a id="675" class="Symbol">)</a>
<a id="677" class="Keyword">open</a> <a id="682" class="Keyword">import</a> <a id="689" href="Data.Bool.Base.html" class="Module">Data.Bool.Base</a>             <a id="716" class="Keyword">using</a> <a id="722" class="Symbol">(</a><a id="723" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="727" class="Symbol">;</a> <a id="729" href="Data.Bool.Base.html#1283" class="Function Operator">if_then_else_</a><a id="742" class="Symbol">;</a> <a id="744" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="748" class="Symbol">;</a> <a id="750" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="755" class="Symbol">)</a>
<a id="757" class="Keyword">open</a> <a id="762" class="Keyword">import</a> <a id="769" href="Data.Unit.Base.html" class="Module">Data.Unit.Base</a>             <a id="796" class="Keyword">using</a> <a id="802" class="Symbol">(</a><a id="803" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="804" class="Symbol">)</a>
<a id="806" class="Keyword">open</a> <a id="811" class="Keyword">import</a> <a id="818" href="Data.String.Base.html" class="Module">Data.String.Base</a> <a id="835" class="Symbol">as</a> <a id="838" class="Module">String</a> <a id="845" class="Keyword">using</a> <a id="851" class="Symbol">(</a><a id="852" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="858" class="Symbol">;</a> <a id="860" href="Data.String.Base.html#2404" class="Function Operator">_++_</a><a id="864" class="Symbol">;</a> <a id="866" href="Data.String.Base.html#2864" class="Function">parens</a><a id="872" class="Symbol">)</a>
<a id="874" class="Keyword">open</a> <a id="879" class="Keyword">import</a> <a id="886" href="Data.Product.html" class="Module">Data.Product</a>               <a id="913" class="Keyword">using</a> <a id="919" class="Symbol">(</a><a id="920" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="923" class="Symbol">;</a> <a id="925" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="930" class="Symbol">)</a>
<a id="932" class="Keyword">open</a> <a id="937" class="Keyword">import</a> <a id="944" href="Function.html" class="Module">Function</a>
<a id="953" class="Keyword">open</a> <a id="958" class="Keyword">import</a> <a id="965" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a>

<a id="993" class="Keyword">open</a> <a id="998" class="Keyword">import</a> <a id="1005" href="Reflection.html" class="Module">Reflection</a>
<a id="1016" class="Keyword">open</a> <a id="1021" class="Keyword">import</a> <a id="1028" href="Reflection.AST.Argument.html" class="Module">Reflection.AST.Argument</a>
<a id="1052" class="Keyword">open</a> <a id="1057" class="Keyword">import</a> <a id="1064" href="Reflection.AST.Term.html" class="Module">Reflection.AST.Term</a> <a id="1084" class="Symbol">as</a> <a id="1087" class="Module">Term</a>
<a id="1092" class="Keyword">open</a> <a id="1097" class="Keyword">import</a> <a id="1104" href="Reflection.AST.AlphaEquality.html" class="Module">Reflection.AST.AlphaEquality</a>
<a id="1133" class="Keyword">open</a> <a id="1138" class="Keyword">import</a> <a id="1145" href="Reflection.AST.Name.html" class="Module">Reflection.AST.Name</a> <a id="1165" class="Symbol">as</a> <a id="1168" class="Module">Name</a>
<a id="1173" class="Keyword">open</a> <a id="1178" class="Keyword">import</a> <a id="1185" href="Reflection.TCM.Syntax.html" class="Module">Reflection.TCM.Syntax</a>
<a id="1207" class="Keyword">open</a> <a id="1212" class="Keyword">import</a> <a id="1219" href="Data.Nat.Reflection.html" class="Module">Data.Nat.Reflection</a>
<a id="1239" class="Keyword">open</a> <a id="1244" class="Keyword">import</a> <a id="1251" href="Data.List.Reflection.html" class="Module">Data.List.Reflection</a>
<a id="1272" class="Keyword">import</a> <a id="1279" href="Data.Vec.Reflection.html" class="Module">Data.Vec.Reflection</a> <a id="1299" class="Symbol">as</a> <a id="1302" class="Module">Vec</a>

<a id="1307" class="Keyword">open</a> <a id="1312" class="Keyword">import</a> <a id="1319" href="Tactic.RingSolver.NonReflective.html" class="Module">Tactic.RingSolver.NonReflective</a> <a id="1351" class="Keyword">renaming</a> <a id="1360" class="Symbol">(</a><a id="1361" href="Tactic.RingSolver.NonReflective.html#2953" class="Function">solve</a> <a id="1367" class="Symbol">to</a> <a id="1370" class="Function">solver</a><a id="1376" class="Symbol">)</a>
<a id="1378" class="Keyword">open</a> <a id="1383" class="Keyword">import</a> <a id="1390" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html" class="Module">Tactic.RingSolver.Core.AlmostCommutativeRing</a>
<a id="1435" class="Keyword">open</a> <a id="1440" class="Keyword">import</a> <a id="1447" href="Tactic.RingSolver.Core.NatSet.html" class="Module">Tactic.RingSolver.Core.NatSet</a> <a id="1477" class="Symbol">as</a> <a id="1480" class="Module">NatSet</a>

<a id="1488" class="Keyword">open</a> <a id="1493" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1249" class="Module">AlmostCommutativeRing</a>

<a id="1516" class="Comment">------------------------------------------------------------------------</a>
<a id="1589" class="Comment">-- Utilities</a>

<a id="1603" class="Keyword">private</a>
  <a id="VarMap"></a><a id="1613" href="Tactic.RingSolver.html#1613" class="Function">VarMap</a> <a id="1620" class="Symbol">:</a> <a id="1622" href="Agda.Primitive.html#326" class="Primitive">Set</a>
  <a id="1628" href="Tactic.RingSolver.html#1613" class="Function">VarMap</a> <a id="1635" class="Symbol">=</a> <a id="1637" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="1639" class="Symbol">→</a> <a id="1641" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1647" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>

  <a id="getVisible"></a><a id="1655" href="Tactic.RingSolver.html#1655" class="Function">getVisible</a> <a id="1666" class="Symbol">:</a> <a id="1668" href="Agda.Builtin.Reflection.html#3697" class="Datatype">Arg</a> <a id="1672" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1677" class="Symbol">→</a> <a id="1679" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1685" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="1692" href="Tactic.RingSolver.html#1655" class="Function">getVisible</a> <a id="1703" class="Symbol">(</a><a id="1704" href="Agda.Builtin.Reflection.html#3733" class="InductiveConstructor">arg</a> <a id="1708" class="Symbol">(</a><a id="1709" href="Agda.Builtin.Reflection.html#3638" class="InductiveConstructor">arg-info</a> <a id="1718" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a> <a id="1726" class="Symbol">_)</a> <a id="1729" href="Tactic.RingSolver.html#1729" class="Bound">x</a><a id="1730" class="Symbol">)</a> <a id="1732" class="Symbol">=</a> <a id="1734" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="1739" href="Tactic.RingSolver.html#1729" class="Bound">x</a>
  <a id="1743" href="Tactic.RingSolver.html#1655" class="CatchallClause Function">getVisible</a><a id="1753" class="CatchallClause"> </a><a id="1754" class="CatchallClause Symbol">_</a>                            <a id="1783" class="Symbol">=</a> <a id="1785" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="getVisibleArgs"></a><a id="1796" href="Tactic.RingSolver.html#1796" class="Function">getVisibleArgs</a> <a id="1811" class="Symbol">:</a> <a id="1813" class="Symbol">∀</a> <a id="1815" href="Tactic.RingSolver.html#1815" class="Bound">n</a> <a id="1817" class="Symbol">→</a> <a id="1819" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1824" class="Symbol">→</a> <a id="1826" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1832" class="Symbol">(</a><a id="1833" href="Data.Vec.Base.html#1051" class="Datatype">Vec</a> <a id="1837" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1842" href="Tactic.RingSolver.html#1815" class="Bound">n</a><a id="1843" class="Symbol">)</a>
  <a id="1847" href="Tactic.RingSolver.html#1796" class="Function">getVisibleArgs</a> <a id="1862" href="Tactic.RingSolver.html#1862" class="Bound">n</a> <a id="1864" class="Symbol">(</a><a id="1865" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="1869" class="Symbol">_</a> <a id="1871" href="Tactic.RingSolver.html#1871" class="Bound">xs</a><a id="1873" class="Symbol">)</a> <a id="1875" class="Symbol">=</a> <a id="1877" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="1887" href="Data.Vec.Base.html#8726" class="Function">Vec.reverse</a>
    <a id="1903" class="Symbol">(</a><a id="1904" href="Data.List.Base.html#4308" class="Function">List.foldl</a> <a id="1915" href="Tactic.RingSolver.html#1966" class="Function">f</a> <a id="1917" href="Tactic.RingSolver.html#2110" class="Function">c</a> <a id="1919" class="Symbol">(</a><a id="1920" href="Data.List.Base.html#1648" class="Function">List.mapMaybe</a> <a id="1934" href="Tactic.RingSolver.html#1655" class="Function">getVisible</a> <a id="1945" href="Tactic.RingSolver.html#1871" class="Bound">xs</a><a id="1947" class="Symbol">)</a> <a id="1949" href="Tactic.RingSolver.html#1862" class="Bound">n</a><a id="1950" class="Symbol">)</a>
    <a id="1956" class="Keyword">where</a>
    <a id="1966" href="Tactic.RingSolver.html#1966" class="Function">f</a> <a id="1968" class="Symbol">:</a> <a id="1970" class="Symbol">(∀</a> <a id="1973" href="Tactic.RingSolver.html#1973" class="Bound">n</a> <a id="1975" class="Symbol">→</a> <a id="1977" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="1983" class="Symbol">(</a><a id="1984" href="Data.Vec.Base.html#1051" class="Datatype">Vec</a> <a id="1988" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="1993" href="Tactic.RingSolver.html#1973" class="Bound">n</a><a id="1994" class="Symbol">))</a> <a id="1997" class="Symbol">→</a> <a id="1999" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2004" class="Symbol">→</a> <a id="2006" class="Symbol">∀</a> <a id="2008" href="Tactic.RingSolver.html#2008" class="Bound">n</a> <a id="2010" class="Symbol">→</a> <a id="2012" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2018" class="Symbol">(</a><a id="2019" href="Data.Vec.Base.html#1051" class="Datatype">Vec</a> <a id="2023" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2028" href="Tactic.RingSolver.html#2008" class="Bound">n</a><a id="2029" class="Symbol">)</a>
    <a id="2035" href="Tactic.RingSolver.html#1966" class="Function">f</a> <a id="2037" href="Tactic.RingSolver.html#2037" class="Bound">xs</a> <a id="2040" href="Tactic.RingSolver.html#2040" class="Bound">x</a> <a id="2042" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="2050" class="Symbol">=</a> <a id="2052" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2057" href="Data.Vec.Base.html#1087" class="InductiveConstructor">[]</a>
    <a id="2064" href="Tactic.RingSolver.html#1966" class="Function">f</a> <a id="2066" href="Tactic.RingSolver.html#2066" class="Bound">xs</a> <a id="2069" href="Tactic.RingSolver.html#2069" class="Bound">x</a> <a id="2071" class="Symbol">(</a><a id="2072" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2076" href="Tactic.RingSolver.html#2076" class="Bound">n</a><a id="2077" class="Symbol">)</a> <a id="2079" class="Symbol">=</a> <a id="2081" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="2091" class="Symbol">(</a><a id="2092" href="Tactic.RingSolver.html#2069" class="Bound">x</a> <a id="2094" href="Data.Vec.Base.html#1106" class="InductiveConstructor Operator">∷_</a><a id="2096" class="Symbol">)</a> <a id="2098" class="Symbol">(</a><a id="2099" href="Tactic.RingSolver.html#2066" class="Bound">xs</a> <a id="2102" href="Tactic.RingSolver.html#2076" class="Bound">n</a><a id="2103" class="Symbol">)</a>

    <a id="2110" href="Tactic.RingSolver.html#2110" class="Function">c</a> <a id="2112" class="Symbol">:</a> <a id="2114" class="Symbol">∀</a> <a id="2116" href="Tactic.RingSolver.html#2116" class="Bound">n</a> <a id="2118" class="Symbol">→</a> <a id="2120" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="2126" class="Symbol">(</a><a id="2127" href="Data.Vec.Base.html#1051" class="Datatype">Vec</a> <a id="2131" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2136" href="Tactic.RingSolver.html#2116" class="Bound">n</a><a id="2137" class="Symbol">)</a>
    <a id="2143" href="Tactic.RingSolver.html#2110" class="Function">c</a> <a id="2145" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>     <a id="2154" class="Symbol">=</a> <a id="2156" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="2161" href="Data.Vec.Base.html#1087" class="InductiveConstructor">[]</a>
    <a id="2168" href="Tactic.RingSolver.html#2110" class="Function">c</a> <a id="2170" class="Symbol">(</a><a id="2171" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2175" class="Symbol">_</a> <a id="2177" class="Symbol">)</a> <a id="2179" class="Symbol">=</a> <a id="2181" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>
  <a id="2191" href="Tactic.RingSolver.html#1796" class="CatchallClause Function">getVisibleArgs</a><a id="2205" class="CatchallClause"> </a><a id="2206" class="CatchallClause Symbol">_</a><a id="2207" class="CatchallClause"> </a><a id="2208" class="CatchallClause Symbol">_</a> <a id="2210" class="Symbol">=</a> <a id="2212" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

  <a id="curriedTerm"></a><a id="2223" href="Tactic.RingSolver.html#2223" class="Function">curriedTerm</a> <a id="2235" class="Symbol">:</a> <a id="2237" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="2244" class="Symbol">→</a> <a id="2246" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="2253" href="Tactic.RingSolver.html#2223" class="Function">curriedTerm</a> <a id="2265" class="Symbol">=</a> <a id="2267" href="Data.List.Base.html#4207" class="Function">List.foldr</a> <a id="2278" href="Tactic.RingSolver.html#2319" class="Function">go</a> <a id="2281" href="Data.Vec.Reflection.html#670" class="Function">Vec.`[]</a> <a id="2289" href="Function.Base.html#1106" class="Function Operator">∘</a> <a id="2291" href="Tactic.RingSolver.Core.NatSet.html#3284" class="Function">NatSet.toList</a>
    <a id="2309" class="Keyword">where</a>
    <a id="2319" href="Tactic.RingSolver.html#2319" class="Function">go</a> <a id="2322" class="Symbol">:</a> <a id="2324" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="2326" class="Symbol">→</a> <a id="2328" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2333" class="Symbol">→</a> <a id="2335" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
    <a id="2344" href="Tactic.RingSolver.html#2319" class="Function">go</a> <a id="2347" href="Tactic.RingSolver.html#2347" class="Bound">x</a> <a id="2349" href="Tactic.RingSolver.html#2349" class="Bound">xs</a> <a id="2352" class="Symbol">=</a> <a id="2354" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="2358" href="Tactic.RingSolver.html#2347" class="Bound">x</a> <a id="2360" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="2363" href="Data.Vec.Reflection.html#720" class="Function Operator">Vec.`∷</a> <a id="2370" href="Tactic.RingSolver.html#2349" class="Bound">xs</a>

<a id="2374" class="Comment">------------------------------------------------------------------------</a>
<a id="2447" class="Comment">-- Reflection utilities for rings</a>

<a id="`AlmostCommutativeRing"></a><a id="2482" href="Tactic.RingSolver.html#2482" class="Function">`AlmostCommutativeRing</a> <a id="2505" class="Symbol">:</a> <a id="2507" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="2512" href="Tactic.RingSolver.html#2482" class="Function">`AlmostCommutativeRing</a> <a id="2535" class="Symbol">=</a> <a id="2537" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="2541" class="Symbol">(</a><a id="2542" class="Keyword">quote</a> <a id="2548" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1249" class="Record">AlmostCommutativeRing</a><a id="2569" class="Symbol">)</a> <a id="2571" class="Symbol">(</a><a id="2572" class="Number">2</a> <a id="2574" href="Reflection.AST.Term.html#2519" class="Function Operator">⋯⟨∷⟩</a> <a id="2579" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="2581" class="Symbol">)</a>

<a id="2584" class="Keyword">record</a> <a id="RingOperatorTerms"></a><a id="2591" href="Tactic.RingSolver.html#2591" class="Record">RingOperatorTerms</a> <a id="2609" class="Symbol">:</a> <a id="2611" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="2615" class="Keyword">where</a>
  <a id="2623" class="Keyword">constructor</a> <a id="add⇒_mul⇒_pow⇒_neg⇒_sub⇒_"></a><a id="2635" href="Tactic.RingSolver.html#2635" class="InductiveConstructor Operator">add⇒_mul⇒_pow⇒_neg⇒_sub⇒_</a>
  <a id="2663" class="Keyword">field</a>
    <a id="RingOperatorTerms.add"></a><a id="2673" href="Tactic.RingSolver.html#2673" class="Field">add</a> <a id="RingOperatorTerms.mul"></a><a id="2677" href="Tactic.RingSolver.html#2677" class="Field">mul</a> <a id="RingOperatorTerms.pow"></a><a id="2681" href="Tactic.RingSolver.html#2681" class="Field">pow</a> <a id="RingOperatorTerms.neg"></a><a id="2685" href="Tactic.RingSolver.html#2685" class="Field">neg</a> <a id="RingOperatorTerms.sub"></a><a id="2689" href="Tactic.RingSolver.html#2689" class="Field">sub</a> <a id="2693" class="Symbol">:</a> <a id="2695" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>

<a id="checkIsRing"></a><a id="2701" href="Tactic.RingSolver.html#2701" class="Function">checkIsRing</a> <a id="2713" class="Symbol">:</a> <a id="2715" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="2720" class="Symbol">→</a> <a id="2722" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="2725" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="2730" href="Tactic.RingSolver.html#2701" class="Function">checkIsRing</a> <a id="2742" href="Tactic.RingSolver.html#2742" class="Bound">ring</a> <a id="2747" class="Symbol">=</a> <a id="2749" href="Agda.Builtin.Reflection.html#8530" class="Postulate">checkType</a> <a id="2759" href="Tactic.RingSolver.html#2742" class="Bound">ring</a> <a id="2764" href="Tactic.RingSolver.html#2482" class="Function">`AlmostCommutativeRing</a>

<a id="2788" class="Keyword">module</a> <a id="RingReflection"></a><a id="2795" href="Tactic.RingSolver.html#2795" class="Module">RingReflection</a> <a id="2810" class="Symbol">(</a><a id="2811" href="Tactic.RingSolver.html#2811" class="Bound">`ring</a> <a id="2817" class="Symbol">:</a> <a id="2819" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="2823" class="Symbol">)</a> <a id="2825" class="Keyword">where</a>

  <a id="2834" class="Comment">-- Takes the name of a function that takes the ring as it&#39;s first</a>
  <a id="2902" class="Comment">-- explicit argument and the terms of it&#39;s arguments and inserts</a>
  <a id="2969" class="Comment">-- the required ring arguments</a>
  <a id="3002" class="Comment">--   e.g. &quot;_+_&quot; $ʳ xs = &quot;_+_ {_} {_} ring xs&quot;</a>
  <a id="3050" class="Keyword">infixr</a> <a id="3057" class="Number">6</a> <a id="3059" href="Tactic.RingSolver.html#3066" class="Function Operator">_$ʳ_</a>
  <a id="RingReflection._$ʳ_"></a><a id="3066" href="Tactic.RingSolver.html#3066" class="Function Operator">_$ʳ_</a> <a id="3071" class="Symbol">:</a> <a id="3073" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="3078" class="Symbol">→</a> <a id="3080" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="3085" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3090" class="Symbol">→</a> <a id="3092" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3099" href="Tactic.RingSolver.html#3099" class="Bound">nm</a> <a id="3102" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="3105" href="Tactic.RingSolver.html#3105" class="Bound">args</a> <a id="3110" class="Symbol">=</a> <a id="3112" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="3116" href="Tactic.RingSolver.html#3099" class="Bound">nm</a> <a id="3119" class="Symbol">(</a><a id="3120" class="Number">2</a> <a id="3122" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="3127" href="Tactic.RingSolver.html#2811" class="Bound">`ring</a> <a id="3133" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3137" href="Tactic.RingSolver.html#3105" class="Bound">args</a><a id="3141" class="Symbol">)</a>

  <a id="RingReflection.`Carrier"></a><a id="3146" href="Tactic.RingSolver.html#3146" class="Function">`Carrier</a> <a id="3155" class="Symbol">:</a> <a id="3157" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3164" href="Tactic.RingSolver.html#3146" class="Function">`Carrier</a> <a id="3173" class="Symbol">=</a> <a id="3175" class="Keyword">quote</a> <a id="3181" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1387" class="Field">Carrier</a> <a id="3189" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="3192" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>

  <a id="RingReflection.`refl"></a><a id="3198" href="Tactic.RingSolver.html#3198" class="Function">`refl</a> <a id="3204" class="Symbol">:</a> <a id="3206" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3213" href="Tactic.RingSolver.html#3198" class="Function">`refl</a> <a id="3219" class="Symbol">=</a> <a id="3221" class="Keyword">quote</a> <a id="3227" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2550" class="Function">refl</a> <a id="3232" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="3235" class="Symbol">(</a><a id="3236" class="Number">1</a> <a id="3238" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="3243" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3245" class="Symbol">)</a>

  <a id="RingReflection.`sym"></a><a id="3250" href="Tactic.RingSolver.html#3250" class="Function">`sym</a> <a id="3255" class="Symbol">:</a> <a id="3257" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3262" class="Symbol">→</a> <a id="3264" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3271" href="Tactic.RingSolver.html#3250" class="Function">`sym</a> <a id="3276" href="Tactic.RingSolver.html#3276" class="Bound">x≈y</a> <a id="3280" class="Symbol">=</a> <a id="3282" class="Keyword">quote</a> <a id="3288" href="Relation.Binary.Structures.html#1594" class="Function">sym</a> <a id="3292" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="3295" class="Symbol">(</a><a id="3296" class="Number">2</a> <a id="3298" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="3303" href="Tactic.RingSolver.html#3276" class="Bound">x≈y</a> <a id="3307" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3311" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3313" class="Symbol">)</a>

  <a id="RingReflection.`trans"></a><a id="3318" href="Tactic.RingSolver.html#3318" class="Function">`trans</a> <a id="3325" class="Symbol">:</a> <a id="3327" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3332" class="Symbol">→</a> <a id="3334" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="3339" class="Symbol">→</a> <a id="3341" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="3348" href="Tactic.RingSolver.html#3318" class="Function">`trans</a> <a id="3355" href="Tactic.RingSolver.html#3355" class="Bound">x≈y</a> <a id="3359" href="Tactic.RingSolver.html#3359" class="Bound">y≈z</a> <a id="3363" class="Symbol">=</a> <a id="3365" class="Keyword">quote</a> <a id="3371" href="Relation.Binary.Structures.html#1620" class="Function">trans</a> <a id="3377" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="3380" class="Symbol">(</a><a id="3381" class="Number">3</a> <a id="3383" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="3388" href="Tactic.RingSolver.html#3355" class="Bound">x≈y</a> <a id="3392" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3396" href="Tactic.RingSolver.html#3359" class="Bound">y≈z</a> <a id="3400" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="3404" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3406" class="Symbol">)</a>

  <a id="3411" class="Comment">-- Normalises each of the fields of the ring operator so we can</a>
  <a id="3477" class="Comment">-- compare the result against the normalised definitions we come</a>
  <a id="3544" class="Comment">-- across when converting the term passed to the macro.</a>
  <a id="RingReflection.getRingOperatorTerms"></a><a id="3602" href="Tactic.RingSolver.html#3602" class="Function">getRingOperatorTerms</a> <a id="3623" class="Symbol">:</a> <a id="3625" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="3628" href="Tactic.RingSolver.html#2591" class="Record">RingOperatorTerms</a>
  <a id="3648" href="Tactic.RingSolver.html#3602" class="Function">getRingOperatorTerms</a> <a id="3669" class="Symbol">=</a> <a id="3671" class="Symbol">⦇</a>
    <a id="3677" href="Tactic.RingSolver.html#2635" class="InductiveConstructor Operator">add⇒</a> <a id="3682" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3692" class="Symbol">(</a><a id="3693" class="Keyword">quote</a> <a id="3699" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1467" class="Field Operator">_+_</a>  <a id="3704" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="3707" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3709" class="Symbol">)</a>
    <a id="3715" href="Tactic.RingSolver.html#2635" class="InductiveConstructor Operator">mul⇒</a> <a id="3720" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3730" class="Symbol">(</a><a id="3731" class="Keyword">quote</a> <a id="3737" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1509" class="Field Operator">_*_</a>  <a id="3742" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="3745" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3747" class="Symbol">)</a>
    <a id="3753" href="Tactic.RingSolver.html#2635" class="InductiveConstructor Operator">pow⇒</a> <a id="3758" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3768" class="Symbol">(</a><a id="3769" class="Keyword">quote</a> <a id="3775" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2408" class="Function Operator">_^_</a>  <a id="3780" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="3783" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3785" class="Symbol">)</a>
    <a id="3791" href="Tactic.RingSolver.html#2635" class="InductiveConstructor Operator">neg⇒</a> <a id="3796" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3806" class="Symbol">(</a><a id="3807" class="Keyword">quote</a> <a id="3813" class="Symbol">(</a><a id="3814" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1551" class="Field Operator">-_</a><a id="3816" class="Symbol">)</a> <a id="3818" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="3821" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3823" class="Symbol">)</a>
    <a id="3829" href="Tactic.RingSolver.html#2635" class="InductiveConstructor Operator">sub⇒</a> <a id="3834" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="3844" class="Symbol">(</a><a id="3845" class="Keyword">quote</a> <a id="3851" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2491" class="Function Operator">_-_</a>  <a id="3856" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="3859" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3861" class="Symbol">)</a>
    <a id="3867" class="Symbol">⦈</a>

<a id="3870" class="Comment">------------------------------------------------------------------------</a>
<a id="3943" class="Comment">-- Reflection utilities for ring solver</a>

<a id="3984" class="Keyword">module</a> <a id="RingSolverReflection"></a><a id="3991" href="Tactic.RingSolver.html#3991" class="Module">RingSolverReflection</a> <a id="4012" class="Symbol">(</a><a id="4013" href="Tactic.RingSolver.html#4013" class="Bound">ring</a> <a id="4018" class="Symbol">:</a> <a id="4020" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="4024" class="Symbol">)</a> <a id="4026" class="Symbol">(</a><a id="4027" href="Tactic.RingSolver.html#4027" class="Bound">numberOfVariables</a> <a id="4045" class="Symbol">:</a> <a id="4047" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4048" class="Symbol">)</a> <a id="4050" class="Keyword">where</a>
  <a id="4058" class="Keyword">open</a> <a id="4063" href="Tactic.RingSolver.html#2795" class="Module">RingReflection</a> <a id="4078" href="Tactic.RingSolver.html#4013" class="Bound">ring</a>

  <a id="RingSolverReflection.`numberOfVariables"></a><a id="4086" href="Tactic.RingSolver.html#4086" class="Function">`numberOfVariables</a> <a id="4105" class="Symbol">:</a> <a id="4107" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4114" href="Tactic.RingSolver.html#4086" class="Function">`numberOfVariables</a> <a id="4133" class="Symbol">=</a> <a id="4135" href="Data.Nat.Reflection.html#644" class="Function">toTerm</a> <a id="4142" href="Tactic.RingSolver.html#4027" class="Bound">numberOfVariables</a>

  <a id="4163" class="Comment">-- This function applies the hidden arguments that the constructors</a>
  <a id="4233" class="Comment">-- that Expr needs. The first is the universe level, the second is the</a>
  <a id="4306" class="Comment">-- type it contains, and the third is the number of variables it&#39;s</a>
  <a id="4375" class="Comment">-- indexed by. All three of these could likely be inferred, but to</a>
  <a id="4444" class="Comment">-- make things easier we supply the third because we know it.</a>
  <a id="4508" class="Keyword">infix</a> <a id="4514" class="Number">-1</a> <a id="4517" href="Tactic.RingSolver.html#4524" class="Function Operator">_$ᵉ_</a>
  <a id="RingSolverReflection._$ᵉ_"></a><a id="4524" href="Tactic.RingSolver.html#4524" class="Function Operator">_$ᵉ_</a> <a id="4529" class="Symbol">:</a> <a id="4531" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="4536" class="Symbol">→</a> <a id="4538" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4543" class="Symbol">(</a><a id="4544" href="Agda.Builtin.Reflection.html#3697" class="Datatype">Arg</a> <a id="4548" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a><a id="4552" class="Symbol">)</a> <a id="4554" class="Symbol">→</a> <a id="4556" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4563" href="Tactic.RingSolver.html#4563" class="Bound">e</a> <a id="4565" href="Tactic.RingSolver.html#4524" class="Function Operator">$ᵉ</a> <a id="4568" href="Tactic.RingSolver.html#4568" class="Bound">xs</a> <a id="4571" class="Symbol">=</a> <a id="4573" href="Agda.Builtin.Reflection.html#4846" class="InductiveConstructor">con</a> <a id="4577" href="Tactic.RingSolver.html#4563" class="Bound">e</a> <a id="4579" class="Symbol">(</a><a id="4580" class="Number">1</a> <a id="4582" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="4587" href="Tactic.RingSolver.html#3146" class="Function">`Carrier</a> <a id="4596" href="Reflection.AST.Argument.html#1751" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4600" href="Tactic.RingSolver.html#4086" class="Function">`numberOfVariables</a> <a id="4619" href="Reflection.AST.Argument.html#1751" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4623" href="Tactic.RingSolver.html#4568" class="Bound">xs</a><a id="4625" class="Symbol">)</a>

  <a id="4630" class="Comment">-- A constant expression.</a>
  <a id="RingSolverReflection.`Κ"></a><a id="4658" href="Tactic.RingSolver.html#4658" class="Function">`Κ</a> <a id="4661" class="Symbol">:</a> <a id="4663" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4668" class="Symbol">→</a> <a id="4670" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4677" href="Tactic.RingSolver.html#4658" class="Function">`Κ</a> <a id="4680" href="Tactic.RingSolver.html#4680" class="Bound">x</a> <a id="4682" class="Symbol">=</a> <a id="4684" class="Keyword">quote</a> <a id="4690" href="Tactic.RingSolver.Core.Expression.html#538" class="InductiveConstructor">Κ</a> <a id="4692" href="Tactic.RingSolver.html#4524" class="Function Operator">$ᵉ</a> <a id="4695" class="Symbol">(</a><a id="4696" href="Tactic.RingSolver.html#4680" class="Bound">x</a> <a id="4698" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4702" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4704" class="Symbol">)</a>

  <a id="RingSolverReflection.`I"></a><a id="4709" href="Tactic.RingSolver.html#4709" class="Function">`I</a> <a id="4712" class="Symbol">:</a> <a id="4714" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4719" class="Symbol">→</a> <a id="4721" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4728" href="Tactic.RingSolver.html#4709" class="Function">`I</a> <a id="4731" href="Tactic.RingSolver.html#4731" class="Bound">x</a> <a id="4733" class="Symbol">=</a> <a id="4735" class="Keyword">quote</a> <a id="4741" href="Tactic.RingSolver.Core.Expression.html#589" class="InductiveConstructor">Ι</a> <a id="4743" href="Tactic.RingSolver.html#4524" class="Function Operator">$ᵉ</a> <a id="4746" class="Symbol">(</a><a id="4747" href="Tactic.RingSolver.html#4731" class="Bound">x</a> <a id="4749" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4753" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4755" class="Symbol">)</a>

  <a id="RingSolverReflection._`⊜_"></a><a id="4760" href="Tactic.RingSolver.html#4760" class="Function Operator">_`⊜_</a> <a id="4765" class="Symbol">:</a> <a id="4767" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4772" class="Symbol">→</a> <a id="4774" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4779" class="Symbol">→</a> <a id="4781" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4788" href="Tactic.RingSolver.html#4788" class="Bound">x</a> <a id="4790" href="Tactic.RingSolver.html#4760" class="Function Operator">`⊜</a> <a id="4793" href="Tactic.RingSolver.html#4793" class="Bound">y</a> <a id="4795" class="Symbol">=</a> <a id="4797" class="Keyword">quote</a> <a id="4803" href="Tactic.RingSolver.NonReflective.html#3315" class="Function Operator">_⊜_</a>  <a id="4808" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="4811" class="Symbol">(</a><a id="4812" href="Tactic.RingSolver.html#4086" class="Function">`numberOfVariables</a> <a id="4831" href="Reflection.AST.Argument.html#1751" class="InductiveConstructor Operator">⟅∷⟆</a> <a id="4835" href="Tactic.RingSolver.html#4788" class="Bound">x</a> <a id="4837" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4841" href="Tactic.RingSolver.html#4793" class="Bound">y</a> <a id="4843" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4847" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4849" class="Symbol">)</a>

  <a id="RingSolverReflection.`correct"></a><a id="4854" href="Tactic.RingSolver.html#4854" class="Function">`correct</a> <a id="4863" class="Symbol">:</a> <a id="4865" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4870" class="Symbol">→</a> <a id="4872" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4877" class="Symbol">→</a> <a id="4879" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4886" href="Tactic.RingSolver.html#4854" class="Function">`correct</a> <a id="4895" href="Tactic.RingSolver.html#4895" class="Bound">x</a> <a id="4897" href="Tactic.RingSolver.html#4897" class="Bound">ρ</a> <a id="4899" class="Symbol">=</a> <a id="4901" class="Keyword">quote</a> <a id="4907" href="Tactic.RingSolver.NonReflective.html#2289" class="Function">Ops.correct</a> <a id="4919" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="4922" class="Symbol">(</a><a id="4923" class="Number">1</a> <a id="4925" href="Reflection.AST.Term.html#2832" class="Function Operator">⋯⟅∷⟆</a> <a id="4930" href="Tactic.RingSolver.html#4895" class="Bound">x</a> <a id="4932" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4936" href="Tactic.RingSolver.html#4897" class="Bound">ρ</a> <a id="4938" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="4942" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4944" class="Symbol">)</a>

  <a id="RingSolverReflection.`solver"></a><a id="4949" href="Tactic.RingSolver.html#4949" class="Function">`solver</a> <a id="4957" class="Symbol">:</a> <a id="4959" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4964" class="Symbol">→</a> <a id="4966" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="4971" class="Symbol">→</a> <a id="4973" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="4980" href="Tactic.RingSolver.html#4949" class="Function">`solver</a> <a id="4988" href="Tactic.RingSolver.html#4988" class="Bound">`f</a> <a id="4991" href="Tactic.RingSolver.html#4991" class="Bound">`eq</a> <a id="4995" class="Symbol">=</a> <a id="4997" class="Keyword">quote</a> <a id="5003" href="Tactic.RingSolver.html#1370" class="Function">solver</a> <a id="5010" href="Tactic.RingSolver.html#3066" class="Function Operator">$ʳ</a> <a id="5013" class="Symbol">(</a><a id="5014" href="Tactic.RingSolver.html#4086" class="Function">`numberOfVariables</a> <a id="5033" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5037" href="Tactic.RingSolver.html#4988" class="Bound">`f</a> <a id="5040" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5044" href="Tactic.RingSolver.html#4991" class="Bound">`eq</a> <a id="5048" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="5052" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5054" class="Symbol">)</a>

  <a id="5059" class="Comment">-- Converts the raw terms provided by the macro into the `Expr`s</a>
  <a id="5126" class="Comment">-- used internally by the solver.</a>
  <a id="5162" class="Comment">--</a>
  <a id="5167" class="Comment">-- When trying to figure out the shape of an expression, one of</a>
  <a id="5233" class="Comment">-- the difficult tasks is recognizing where constants in the</a>
  <a id="5296" class="Comment">-- underlying ring are used. If we were only dealing with ℕ, we</a>
  <a id="5362" class="Comment">-- might look for its constructors: however, we want to deal with</a>
  <a id="5430" class="Comment">-- arbitrary types which implement AlmostCommutativeRing. If the</a>
  <a id="5497" class="Comment">-- Term type contained type information we might be able to</a>
  <a id="5559" class="Comment">-- recognize it there, but it doesn&#39;t.</a>
  <a id="5600" class="Comment">--</a>
  <a id="5605" class="Comment">-- We&#39;re in luck, though, because all other cases in the following</a>
  <a id="5674" class="Comment">-- function *are* recognizable. As a result, the &quot;catch-all&quot; case</a>
  <a id="5742" class="Comment">-- will just assume that it has a constant expression.</a>
  <a id="RingSolverReflection.convertTerm"></a><a id="5799" href="Tactic.RingSolver.html#5799" class="Function">convertTerm</a> <a id="5811" class="Symbol">:</a> <a id="5813" href="Tactic.RingSolver.html#2591" class="Record">RingOperatorTerms</a> <a id="5831" class="Symbol">→</a> <a id="5833" href="Tactic.RingSolver.html#1613" class="Function">VarMap</a> <a id="5840" class="Symbol">→</a> <a id="5842" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="5847" class="Symbol">→</a> <a id="5849" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="5852" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="5859" href="Tactic.RingSolver.html#5799" class="Function">convertTerm</a> <a id="5871" href="Tactic.RingSolver.html#5871" class="Bound">operatorTerms</a> <a id="5885" href="Tactic.RingSolver.html#5885" class="Bound">varMap</a> <a id="5892" class="Symbol">=</a> <a id="5894" href="Tactic.RingSolver.html#5971" class="Function">convert</a>
    <a id="5906" class="Keyword">where</a>
    <a id="5916" class="Keyword">open</a> <a id="5921" href="Tactic.RingSolver.html#2591" class="Module">RingOperatorTerms</a> <a id="5939" href="Tactic.RingSolver.html#5871" class="Bound">operatorTerms</a>

    <a id="5958" class="Keyword">mutual</a>
      <a id="5971" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="5979" class="Symbol">:</a> <a id="5981" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="5986" class="Symbol">→</a> <a id="5988" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="5991" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="6002" class="Comment">-- First try and match directly against the fields</a>
      <a id="6059" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="6067" class="Symbol">(</a><a id="6068" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6072" class="Symbol">(</a><a id="6073" class="Keyword">quote</a> <a id="6079" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1467" class="Field Operator">_+_</a><a id="6082" class="Symbol">)</a> <a id="6084" href="Tactic.RingSolver.html#6084" class="Bound">xs</a><a id="6086" class="Symbol">)</a> <a id="6088" class="Symbol">=</a> <a id="6090" href="Tactic.RingSolver.html#7062" class="Function">convertOp₂</a> <a id="6101" class="Symbol">(</a><a id="6102" class="Keyword">quote</a> <a id="6108" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a><a id="6111" class="Symbol">)</a> <a id="6113" href="Tactic.RingSolver.html#6084" class="Bound">xs</a>
      <a id="6122" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="6130" class="Symbol">(</a><a id="6131" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6135" class="Symbol">(</a><a id="6136" class="Keyword">quote</a> <a id="6142" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1509" class="Field Operator">_*_</a><a id="6145" class="Symbol">)</a> <a id="6147" href="Tactic.RingSolver.html#6147" class="Bound">xs</a><a id="6149" class="Symbol">)</a> <a id="6151" class="Symbol">=</a> <a id="6153" href="Tactic.RingSolver.html#7062" class="Function">convertOp₂</a> <a id="6164" class="Symbol">(</a><a id="6165" class="Keyword">quote</a> <a id="6171" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a><a id="6174" class="Symbol">)</a> <a id="6176" href="Tactic.RingSolver.html#6147" class="Bound">xs</a>
      <a id="6185" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="6193" class="Symbol">(</a><a id="6194" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6198" class="Symbol">(</a><a id="6199" class="Keyword">quote</a>  <a id="6206" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#1551" class="Field Operator">-_</a><a id="6208" class="Symbol">)</a> <a id="6210" href="Tactic.RingSolver.html#6210" class="Bound">xs</a><a id="6212" class="Symbol">)</a> <a id="6214" class="Symbol">=</a> <a id="6216" href="Tactic.RingSolver.html#7349" class="Function">convertOp₁</a> <a id="6227" class="Symbol">(</a><a id="6228" class="Keyword">quote</a>  <a id="6235" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="6237" class="Symbol">)</a> <a id="6239" href="Tactic.RingSolver.html#6210" class="Bound">xs</a>
      <a id="6248" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="6256" class="Symbol">(</a><a id="6257" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6261" class="Symbol">(</a><a id="6262" class="Keyword">quote</a> <a id="6268" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2408" class="Function Operator">_^_</a><a id="6271" class="Symbol">)</a> <a id="6273" href="Tactic.RingSolver.html#6273" class="Bound">xs</a><a id="6275" class="Symbol">)</a> <a id="6277" class="Symbol">=</a> <a id="6279" href="Tactic.RingSolver.html#7588" class="Function">convertExp</a> <a id="6290" href="Tactic.RingSolver.html#6273" class="Bound">xs</a>
      <a id="6299" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="6307" class="Symbol">(</a><a id="6308" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6312" class="Symbol">(</a><a id="6313" class="Keyword">quote</a> <a id="6319" href="Tactic.RingSolver.Core.AlmostCommutativeRing.html#2491" class="Function Operator">_-_</a><a id="6322" class="Symbol">)</a> <a id="6324" href="Tactic.RingSolver.html#6324" class="Bound">xs</a><a id="6326" class="Symbol">)</a> <a id="6328" class="Symbol">=</a> <a id="6330" href="Tactic.RingSolver.html#7839" class="Function">convertSub</a> <a id="6341" href="Tactic.RingSolver.html#6324" class="Bound">xs</a>
      <a id="6350" class="Comment">-- Other definitions the underlying implementation of the ring&#39;s fields</a>
      <a id="6428" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="6436" class="Symbol">(</a><a id="6437" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="6441" href="Tactic.RingSolver.html#6441" class="Bound">nm</a>          <a id="6453" href="Tactic.RingSolver.html#6453" class="Bound">xs</a><a id="6455" class="Symbol">)</a> <a id="6457" class="Symbol">=</a> <a id="6459" href="Tactic.RingSolver.html#8140" class="Function">convertUnknownName</a> <a id="6478" href="Tactic.RingSolver.html#6441" class="Bound">nm</a> <a id="6481" href="Tactic.RingSolver.html#6453" class="Bound">xs</a>
      <a id="6490" class="Comment">-- Variables</a>
      <a id="6509" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="6517" href="Tactic.RingSolver.html#6517" class="Bound">v</a><a id="6518" class="Symbol">@(</a><a id="6520" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="6524" href="Tactic.RingSolver.html#6524" class="Bound">x</a> <a id="6526" class="Symbol">_)</a>          <a id="6538" class="Symbol">=</a> <a id="6540" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="6547" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="6549" href="Data.Maybe.Base.html#1632" class="Function">fromMaybe</a> <a id="6559" class="Symbol">(</a><a id="6560" href="Tactic.RingSolver.html#4658" class="Function">`Κ</a> <a id="6563" href="Tactic.RingSolver.html#6517" class="Bound">v</a><a id="6564" class="Symbol">)</a> <a id="6566" class="Symbol">(</a><a id="6567" href="Tactic.RingSolver.html#5885" class="Bound">varMap</a> <a id="6574" href="Tactic.RingSolver.html#6524" class="Bound">x</a><a id="6575" class="Symbol">)</a>
      <a id="6583" class="Comment">-- Special case to recognise &quot;suc&quot; for naturals</a>
      <a id="6637" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="6645" class="Symbol">(</a><a id="6646" href="Data.Nat.Reflection.html#607" class="InductiveConstructor">`suc</a> <a id="6651" href="Tactic.RingSolver.html#6651" class="Bound">x</a><a id="6652" class="Symbol">)</a>             <a id="6666" class="Symbol">=</a> <a id="6668" href="Tactic.RingSolver.html#8663" class="Function">convertSuc</a> <a id="6679" href="Tactic.RingSolver.html#6651" class="Bound">x</a>
      <a id="6687" class="Comment">-- Otherwise we&#39;re forced to treat it as a constant</a>
      <a id="6745" href="Tactic.RingSolver.html#5971" class="CatchallClause Function">convert</a><a id="6752" class="CatchallClause"> </a><a id="6753" href="Tactic.RingSolver.html#6753" class="CatchallClause Bound">t</a>                    <a id="6774" class="Symbol">=</a> <a id="6776" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="6783" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="6785" href="Tactic.RingSolver.html#4658" class="Function">`Κ</a> <a id="6788" href="Tactic.RingSolver.html#6753" class="Bound">t</a>

      <a id="6797" class="Comment">-- Application of a ring operator often doesn&#39;t have a type as</a>
      <a id="6866" class="Comment">-- simple as &quot;Carrier → Carrier → Carrier&quot;: there may be hidden</a>
      <a id="6936" class="Comment">-- arguments, etc. Here, we do our best to handle those cases,</a>
      <a id="7005" class="Comment">-- by just taking the last two explicit arguments.</a>
      <a id="7062" href="Tactic.RingSolver.html#7062" class="Function">convertOp₂</a> <a id="7073" class="Symbol">:</a> <a id="7075" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="7080" class="Symbol">→</a> <a id="7082" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="7087" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7092" class="Symbol">→</a> <a id="7094" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7097" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7108" href="Tactic.RingSolver.html#7062" class="Function">convertOp₂</a> <a id="7119" href="Tactic.RingSolver.html#7119" class="Bound">nm</a> <a id="7122" class="Symbol">(</a><a id="7123" href="Tactic.RingSolver.html#7123" class="Bound">x</a> <a id="7125" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7129" href="Tactic.RingSolver.html#7129" class="Bound">y</a> <a id="7131" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7135" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7137" class="Symbol">)</a> <a id="7139" class="Symbol">=</a> <a id="7141" class="Keyword">do</a>
        <a id="7152" href="Tactic.RingSolver.html#7152" class="Bound">x&#39;</a> <a id="7155" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7157" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="7165" href="Tactic.RingSolver.html#7123" class="Bound">x</a>
        <a id="7175" href="Tactic.RingSolver.html#7175" class="Bound">y&#39;</a> <a id="7178" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7180" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="7188" href="Tactic.RingSolver.html#7129" class="Bound">y</a>
        <a id="7198" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7205" class="Symbol">(</a><a id="7206" href="Tactic.RingSolver.html#7119" class="Bound">nm</a> <a id="7209" href="Tactic.RingSolver.html#4524" class="Function Operator">$ᵉ</a> <a id="7212" class="Symbol">(</a><a id="7213" href="Tactic.RingSolver.html#7152" class="Bound">x&#39;</a> <a id="7216" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7220" href="Tactic.RingSolver.html#7175" class="Bound">y&#39;</a> <a id="7223" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7227" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7229" class="Symbol">))</a>
      <a id="7238" href="Tactic.RingSolver.html#7062" class="CatchallClause Function">convertOp₂</a><a id="7248" class="CatchallClause"> </a><a id="7249" href="Tactic.RingSolver.html#7249" class="CatchallClause Bound">nm</a><a id="7251" class="CatchallClause"> </a><a id="7252" class="CatchallClause Symbol">(</a><a id="7253" href="Tactic.RingSolver.html#7253" class="CatchallClause Bound">x</a><a id="7254" class="CatchallClause"> </a><a id="7255" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7256" class="CatchallClause"> </a><a id="7257" href="Tactic.RingSolver.html#7257" class="CatchallClause Bound">xs</a><a id="7259" class="CatchallClause Symbol">)</a>         <a id="7269" class="Symbol">=</a> <a id="7271" href="Tactic.RingSolver.html#7062" class="Function">convertOp₂</a> <a id="7282" href="Tactic.RingSolver.html#7249" class="Bound">nm</a> <a id="7285" href="Tactic.RingSolver.html#7257" class="Bound">xs</a>
      <a id="7294" href="Tactic.RingSolver.html#7062" class="CatchallClause Function">convertOp₂</a><a id="7304" class="CatchallClause"> </a><a id="7305" class="CatchallClause Symbol">_</a><a id="7306" class="CatchallClause">  </a><a id="7308" class="CatchallClause Symbol">_</a>                <a id="7325" class="Symbol">=</a> <a id="7327" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7334" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7349" href="Tactic.RingSolver.html#7349" class="Function">convertOp₁</a> <a id="7360" class="Symbol">:</a> <a id="7362" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="7367" class="Symbol">→</a> <a id="7369" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="7374" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7379" class="Symbol">→</a> <a id="7381" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7384" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7395" href="Tactic.RingSolver.html#7349" class="Function">convertOp₁</a> <a id="7406" href="Tactic.RingSolver.html#7406" class="Bound">nm</a> <a id="7409" class="Symbol">(</a><a id="7410" href="Tactic.RingSolver.html#7410" class="Bound">x</a> <a id="7412" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7416" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7418" class="Symbol">)</a> <a id="7420" class="Symbol">=</a> <a id="7422" class="Keyword">do</a>
        <a id="7433" href="Tactic.RingSolver.html#7433" class="Bound">x&#39;</a> <a id="7436" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7438" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="7446" href="Tactic.RingSolver.html#7410" class="Bound">x</a>
        <a id="7456" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7463" class="Symbol">(</a><a id="7464" href="Tactic.RingSolver.html#7406" class="Bound">nm</a> <a id="7467" href="Tactic.RingSolver.html#4524" class="Function Operator">$ᵉ</a> <a id="7470" class="Symbol">(</a><a id="7471" href="Tactic.RingSolver.html#7433" class="Bound">x&#39;</a> <a id="7474" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7478" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7480" class="Symbol">))</a>
      <a id="7489" href="Tactic.RingSolver.html#7349" class="CatchallClause Function">convertOp₁</a><a id="7499" class="CatchallClause"> </a><a id="7500" href="Tactic.RingSolver.html#7500" class="CatchallClause Bound">nm</a><a id="7502" class="CatchallClause"> </a><a id="7503" class="CatchallClause Symbol">(</a><a id="7504" href="Tactic.RingSolver.html#7504" class="CatchallClause Bound">x</a><a id="7505" class="CatchallClause"> </a><a id="7506" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7507" class="CatchallClause"> </a><a id="7508" href="Tactic.RingSolver.html#7508" class="CatchallClause Bound">xs</a><a id="7510" class="CatchallClause Symbol">)</a>   <a id="7514" class="Symbol">=</a> <a id="7516" href="Tactic.RingSolver.html#7349" class="Function">convertOp₁</a> <a id="7527" href="Tactic.RingSolver.html#7500" class="Bound">nm</a> <a id="7530" href="Tactic.RingSolver.html#7508" class="Bound">xs</a>
      <a id="7539" href="Tactic.RingSolver.html#7349" class="CatchallClause Function">convertOp₁</a><a id="7549" class="CatchallClause"> </a><a id="7550" class="CatchallClause Symbol">_</a><a id="7551" class="CatchallClause">  </a><a id="7553" class="CatchallClause Symbol">_</a>          <a id="7564" class="Symbol">=</a> <a id="7566" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7573" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7588" href="Tactic.RingSolver.html#7588" class="Function">convertExp</a> <a id="7599" class="Symbol">:</a> <a id="7601" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="7606" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7611" class="Symbol">→</a> <a id="7613" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7616" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7627" href="Tactic.RingSolver.html#7588" class="Function">convertExp</a> <a id="7638" class="Symbol">(</a><a id="7639" href="Tactic.RingSolver.html#7639" class="Bound">x</a> <a id="7641" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7645" href="Tactic.RingSolver.html#7645" class="Bound">y</a> <a id="7647" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7651" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7653" class="Symbol">)</a> <a id="7655" class="Symbol">=</a> <a id="7657" class="Keyword">do</a>
        <a id="7668" href="Tactic.RingSolver.html#7668" class="Bound">x&#39;</a> <a id="7671" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7673" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="7681" href="Tactic.RingSolver.html#7639" class="Bound">x</a>
        <a id="7691" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7698" class="Symbol">(</a><a id="7699" class="Keyword">quote</a> <a id="7705" href="Tactic.RingSolver.Core.Expression.html#748" class="InductiveConstructor Operator">_⊛_</a> <a id="7709" href="Tactic.RingSolver.html#4524" class="Function Operator">$ᵉ</a> <a id="7712" class="Symbol">(</a><a id="7713" href="Tactic.RingSolver.html#7668" class="Bound">x&#39;</a> <a id="7716" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7720" href="Tactic.RingSolver.html#7645" class="Bound">y</a> <a id="7722" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7726" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7728" class="Symbol">))</a>
      <a id="7737" href="Tactic.RingSolver.html#7588" class="CatchallClause Function">convertExp</a><a id="7747" class="CatchallClause"> </a><a id="7748" class="CatchallClause Symbol">(</a><a id="7749" href="Tactic.RingSolver.html#7749" class="CatchallClause Bound">x</a><a id="7750" class="CatchallClause"> </a><a id="7751" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="7752" class="CatchallClause"> </a><a id="7753" href="Tactic.RingSolver.html#7753" class="CatchallClause Bound">xs</a><a id="7755" class="CatchallClause Symbol">)</a>         <a id="7765" class="Symbol">=</a> <a id="7767" href="Tactic.RingSolver.html#7588" class="Function">convertExp</a> <a id="7778" href="Tactic.RingSolver.html#7753" class="Bound">xs</a>
      <a id="7787" href="Tactic.RingSolver.html#7588" class="CatchallClause Function">convertExp</a><a id="7797" class="CatchallClause"> </a><a id="7798" class="CatchallClause Symbol">_</a>                <a id="7815" class="Symbol">=</a> <a id="7817" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7824" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="7839" href="Tactic.RingSolver.html#7839" class="Function">convertSub</a> <a id="7850" class="Symbol">:</a> <a id="7852" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="7857" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="7862" class="Symbol">→</a> <a id="7864" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="7867" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="7878" href="Tactic.RingSolver.html#7839" class="Function">convertSub</a> <a id="7889" class="Symbol">(</a><a id="7890" href="Tactic.RingSolver.html#7890" class="Bound">x</a> <a id="7892" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7896" href="Tactic.RingSolver.html#7896" class="Bound">y</a> <a id="7898" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7902" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7904" class="Symbol">)</a> <a id="7906" class="Symbol">=</a> <a id="7908" class="Keyword">do</a>
        <a id="7919" href="Tactic.RingSolver.html#7919" class="Bound">x&#39;</a>  <a id="7923" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7925" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="7933" href="Tactic.RingSolver.html#7890" class="Bound">x</a>
        <a id="7943" href="Tactic.RingSolver.html#7943" class="Bound">-y&#39;</a> <a id="7947" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="7949" href="Tactic.RingSolver.html#7349" class="Function">convertOp₁</a> <a id="7960" class="Symbol">(</a><a id="7961" class="Keyword">quote</a> <a id="7967" class="Symbol">(</a><a id="7968" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="7970" class="Symbol">))</a> <a id="7973" class="Symbol">(</a><a id="7974" href="Tactic.RingSolver.html#7896" class="Bound">y</a> <a id="7976" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="7980" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="7982" class="Symbol">)</a>
        <a id="7992" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="7999" class="Symbol">(</a><a id="8000" class="Keyword">quote</a> <a id="8006" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="8010" href="Tactic.RingSolver.html#4524" class="Function Operator">$ᵉ</a> <a id="8013" href="Tactic.RingSolver.html#7919" class="Bound">x&#39;</a> <a id="8016" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8020" href="Tactic.RingSolver.html#7943" class="Bound">-y&#39;</a> <a id="8024" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8028" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8030" class="Symbol">)</a>
      <a id="8038" href="Tactic.RingSolver.html#7839" class="CatchallClause Function">convertSub</a><a id="8048" class="CatchallClause"> </a><a id="8049" class="CatchallClause Symbol">(</a><a id="8050" href="Tactic.RingSolver.html#8050" class="CatchallClause Bound">x</a><a id="8051" class="CatchallClause"> </a><a id="8052" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="8053" class="CatchallClause"> </a><a id="8054" href="Tactic.RingSolver.html#8054" class="CatchallClause Bound">xs</a><a id="8056" class="CatchallClause Symbol">)</a>         <a id="8066" class="Symbol">=</a> <a id="8068" href="Tactic.RingSolver.html#7839" class="Function">convertSub</a> <a id="8079" href="Tactic.RingSolver.html#8054" class="Bound">xs</a>
      <a id="8088" href="Tactic.RingSolver.html#7839" class="CatchallClause Function">convertSub</a><a id="8098" class="CatchallClause"> </a><a id="8099" class="CatchallClause Symbol">_</a>                <a id="8116" class="Symbol">=</a> <a id="8118" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="8125" href="Agda.Builtin.Reflection.html#5246" class="InductiveConstructor">unknown</a>

      <a id="8140" href="Tactic.RingSolver.html#8140" class="Function">convertUnknownName</a> <a id="8159" class="Symbol">:</a> <a id="8161" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="8166" class="Symbol">→</a> <a id="8168" href="Reflection.AST.Argument.html#1538" class="Function">Args</a> <a id="8173" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8178" class="Symbol">→</a> <a id="8180" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8183" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="8194" href="Tactic.RingSolver.html#8140" class="Function">convertUnknownName</a> <a id="8213" href="Tactic.RingSolver.html#8213" class="Bound">nm</a> <a id="8216" href="Tactic.RingSolver.html#8216" class="Bound">xs</a> <a id="8219" class="Symbol">=</a> <a id="8221" class="Keyword">do</a>
        <a id="8232" href="Tactic.RingSolver.html#8232" class="Bound">nameTerm</a> <a id="8241" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="8243" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a> <a id="8253" class="Symbol">(</a><a id="8254" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="8258" href="Tactic.RingSolver.html#8213" class="Bound">nm</a> <a id="8261" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8263" class="Symbol">)</a>
        <a id="8273" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8276" class="Symbol">(</a><a id="8277" href="Tactic.RingSolver.html#8232" class="Bound">nameTerm</a> <a id="8286" href="Reflection.AST.AlphaEquality.html#1298" class="Field Operator">=α=</a> <a id="8290" href="Tactic.RingSolver.html#2673" class="Function">add</a><a id="8293" class="Symbol">)</a> <a id="8295" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8300" href="Tactic.RingSolver.html#7062" class="Function">convertOp₂</a> <a id="8311" class="Symbol">(</a><a id="8312" class="Keyword">quote</a> <a id="8318" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a><a id="8321" class="Symbol">)</a> <a id="8323" href="Tactic.RingSolver.html#8216" class="Bound">xs</a> <a id="8326" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
          <a id="8341" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8344" class="Symbol">(</a><a id="8345" href="Tactic.RingSolver.html#8232" class="Bound">nameTerm</a> <a id="8354" href="Reflection.AST.AlphaEquality.html#1298" class="Field Operator">=α=</a> <a id="8358" href="Tactic.RingSolver.html#2677" class="Function">mul</a><a id="8361" class="Symbol">)</a> <a id="8363" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8368" href="Tactic.RingSolver.html#7062" class="Function">convertOp₂</a> <a id="8379" class="Symbol">(</a><a id="8380" class="Keyword">quote</a> <a id="8386" href="Tactic.RingSolver.Core.Expression.html#691" class="InductiveConstructor Operator">_⊗_</a><a id="8389" class="Symbol">)</a> <a id="8391" href="Tactic.RingSolver.html#8216" class="Bound">xs</a> <a id="8394" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
            <a id="8411" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8414" class="Symbol">(</a><a id="8415" href="Tactic.RingSolver.html#8232" class="Bound">nameTerm</a> <a id="8424" href="Reflection.AST.AlphaEquality.html#1298" class="Field Operator">=α=</a> <a id="8428" href="Tactic.RingSolver.html#2685" class="Function">neg</a><a id="8431" class="Symbol">)</a> <a id="8433" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8438" href="Tactic.RingSolver.html#7349" class="Function">convertOp₁</a> <a id="8449" class="Symbol">(</a><a id="8450" class="Keyword">quote</a> <a id="8456" href="Tactic.RingSolver.Core.Expression.html#805" class="InductiveConstructor Operator">⊝_</a><a id="8458" class="Symbol">)</a>  <a id="8461" href="Tactic.RingSolver.html#8216" class="Bound">xs</a> <a id="8464" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
              <a id="8483" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8486" class="Symbol">(</a><a id="8487" href="Tactic.RingSolver.html#8232" class="Bound">nameTerm</a> <a id="8496" href="Reflection.AST.AlphaEquality.html#1298" class="Field Operator">=α=</a> <a id="8500" href="Tactic.RingSolver.html#2681" class="Function">pow</a><a id="8503" class="Symbol">)</a> <a id="8505" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8510" href="Tactic.RingSolver.html#7588" class="Function">convertExp</a>             <a id="8533" href="Tactic.RingSolver.html#8216" class="Bound">xs</a> <a id="8536" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                <a id="8557" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="8560" class="Symbol">(</a><a id="8561" href="Tactic.RingSolver.html#8232" class="Bound">nameTerm</a> <a id="8570" href="Reflection.AST.AlphaEquality.html#1298" class="Field Operator">=α=</a> <a id="8574" href="Tactic.RingSolver.html#2689" class="Function">sub</a><a id="8577" class="Symbol">)</a> <a id="8579" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="8584" href="Tactic.RingSolver.html#7839" class="Function">convertSub</a>            <a id="8606" href="Tactic.RingSolver.html#8216" class="Bound">xs</a> <a id="8609" href="Data.Bool.Base.html#1283" class="Function Operator">else</a>
                  <a id="8632" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="8639" class="Symbol">(</a><a id="8640" href="Tactic.RingSolver.html#4658" class="Function">`Κ</a> <a id="8643" class="Symbol">(</a><a id="8644" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="8648" href="Tactic.RingSolver.html#8213" class="Bound">nm</a> <a id="8651" href="Tactic.RingSolver.html#8216" class="Bound">xs</a><a id="8653" class="Symbol">))</a>

      <a id="8663" href="Tactic.RingSolver.html#8663" class="Function">convertSuc</a> <a id="8674" class="Symbol">:</a> <a id="8676" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="8681" class="Symbol">→</a> <a id="8683" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="8686" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
      <a id="8697" href="Tactic.RingSolver.html#8663" class="Function">convertSuc</a> <a id="8708" href="Tactic.RingSolver.html#8708" class="Bound">x</a> <a id="8710" class="Symbol">=</a> <a id="8712" class="Keyword">do</a> <a id="8715" href="Tactic.RingSolver.html#8715" class="Bound">x&#39;</a> <a id="8718" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="8720" href="Tactic.RingSolver.html#5971" class="Function">convert</a> <a id="8728" href="Tactic.RingSolver.html#8708" class="Bound">x</a><a id="8729" class="Symbol">;</a> <a id="8731" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="8738" class="Symbol">(</a><a id="8739" class="Keyword">quote</a> <a id="8745" href="Tactic.RingSolver.Core.Expression.html#640" class="InductiveConstructor Operator">_⊕_</a> <a id="8749" href="Tactic.RingSolver.html#4524" class="Function Operator">$ᵉ</a> <a id="8752" class="Symbol">(</a><a id="8753" href="Tactic.RingSolver.html#4658" class="Function">`Κ</a> <a id="8756" class="Symbol">(</a><a id="8757" href="Data.Nat.Reflection.html#644" class="Function">toTerm</a> <a id="8764" class="Number">1</a><a id="8765" class="Symbol">)</a> <a id="8767" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8771" href="Tactic.RingSolver.html#8715" class="Bound">x&#39;</a> <a id="8774" href="Reflection.AST.Argument.html#1655" class="InductiveConstructor Operator">⟨∷⟩</a> <a id="8778" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8780" class="Symbol">))</a>

<a id="8784" class="Comment">------------------------------------------------------------------------</a>
<a id="8857" class="Comment">-- Macros</a>
<a id="8867" class="Comment">------------------------------------------------------------------------</a>
<a id="8940" class="Comment">-- Quantified macro</a>

<a id="8961" class="Keyword">open</a> <a id="8966" href="Tactic.RingSolver.html#2795" class="Module">RingReflection</a>
<a id="8981" class="Keyword">open</a> <a id="8986" href="Tactic.RingSolver.html#3991" class="Module">RingSolverReflection</a>

<a id="malformedForallTypeError"></a><a id="9008" href="Tactic.RingSolver.html#9008" class="Function">malformedForallTypeError</a> <a id="9033" class="Symbol">:</a> <a id="9035" class="Symbol">∀</a> <a id="9037" class="Symbol">{</a><a id="9038" href="Tactic.RingSolver.html#9038" class="Bound">a</a><a id="9039" class="Symbol">}</a> <a id="9041" class="Symbol">{</a><a id="9042" href="Tactic.RingSolver.html#9042" class="Bound">A</a> <a id="9044" class="Symbol">:</a> <a id="9046" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="9050" href="Tactic.RingSolver.html#9038" class="Bound">a</a><a id="9051" class="Symbol">}</a> <a id="9053" class="Symbol">→</a> <a id="9055" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9060" class="Symbol">→</a> <a id="9062" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="9065" href="Tactic.RingSolver.html#9042" class="Bound">A</a>
<a id="9067" href="Tactic.RingSolver.html#9008" class="Function">malformedForallTypeError</a> <a id="9092" href="Tactic.RingSolver.html#9092" class="Bound">found</a> <a id="9098" class="Symbol">=</a> <a id="9100" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="9112" class="Symbol">(</a> <a id="9114" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="9121" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="9150" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9152" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="9159" class="String">&quot;Expected target type to be like: ∀ x y → x + y ≈ y + x.&quot;</a>
  <a id="9219" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9221" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="9228" class="String">&quot;Instead: &quot;</a>
  <a id="9242" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9244" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="9252" href="Tactic.RingSolver.html#9092" class="Bound">found</a>
  <a id="9260" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="9262" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="9264" class="Symbol">)</a>

<a id="quantifiedVarMap"></a><a id="9267" href="Tactic.RingSolver.html#9267" class="Function">quantifiedVarMap</a> <a id="9284" class="Symbol">:</a> <a id="9286" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a> <a id="9288" class="Symbol">→</a> <a id="9290" href="Tactic.RingSolver.html#1613" class="Function">VarMap</a>
<a id="9297" href="Tactic.RingSolver.html#9267" class="Function">quantifiedVarMap</a> <a id="9314" href="Tactic.RingSolver.html#9314" class="Bound">numVars</a> <a id="9322" href="Tactic.RingSolver.html#9322" class="Bound">i</a> <a id="9324" class="Symbol">=</a>
  <a id="9328" href="Data.Bool.Base.html#1283" class="Function Operator">if</a> <a id="9331" href="Tactic.RingSolver.html#9322" class="Bound">i</a> <a id="9333" href="Data.Nat.Base.html#1230" class="Primitive Operator">&lt;ᵇ</a> <a id="9336" href="Tactic.RingSolver.html#9314" class="Bound">numVars</a>
    <a id="9348" href="Data.Bool.Base.html#1283" class="Function Operator">then</a> <a id="9353" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="9358" class="Symbol">(</a><a id="9359" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="9363" href="Tactic.RingSolver.html#9322" class="Bound">i</a> <a id="9365" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="9367" class="Symbol">)</a>
    <a id="9373" href="Data.Bool.Base.html#1283" class="Function Operator">else</a> <a id="9378" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

<a id="constructCallToSolver"></a><a id="9387" href="Tactic.RingSolver.html#9387" class="Function">constructCallToSolver</a> <a id="9409" class="Symbol">:</a> <a id="9411" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9416" class="Symbol">→</a> <a id="9418" href="Tactic.RingSolver.html#2591" class="Record">RingOperatorTerms</a> <a id="9436" class="Symbol">→</a> <a id="9438" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="9443" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="9450" class="Symbol">→</a> <a id="9452" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9457" class="Symbol">→</a> <a id="9459" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9464" class="Symbol">→</a> <a id="9466" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="9469" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="9474" href="Tactic.RingSolver.html#9387" class="Function">constructCallToSolver</a> <a id="9496" href="Tactic.RingSolver.html#9496" class="Bound">`ring</a> <a id="9502" href="Tactic.RingSolver.html#9502" class="Bound">opNames</a> <a id="9510" href="Tactic.RingSolver.html#9510" class="Bound">variables</a> <a id="9520" href="Tactic.RingSolver.html#9520" class="Bound">`lhs</a> <a id="9525" href="Tactic.RingSolver.html#9525" class="Bound">`rhs</a> <a id="9530" class="Symbol">=</a> <a id="9532" class="Keyword">do</a>
  <a id="9537" href="Tactic.RingSolver.html#9537" class="Bound">`lhsExpr</a> <a id="9546" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="9548" href="Tactic.RingSolver.html#9817" class="Function">conv</a> <a id="9553" href="Tactic.RingSolver.html#9520" class="Bound">`lhs</a>
  <a id="9560" href="Tactic.RingSolver.html#9560" class="Bound">`rhsExpr</a> <a id="9569" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="9571" href="Tactic.RingSolver.html#9817" class="Function">conv</a> <a id="9576" href="Tactic.RingSolver.html#9525" class="Bound">`rhs</a>

  <a id="9584" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="9591" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="9593" href="Tactic.RingSolver.html#4949" class="Function">`solver</a> <a id="9601" href="Tactic.RingSolver.html#9496" class="Bound">`ring</a> <a id="9607" href="Tactic.RingSolver.html#9768" class="Function">numVars</a>
                    <a id="9635" class="Symbol">(</a><a id="9636" href="Reflection.AST.Term.html#3494" class="Function">prependVLams</a> <a id="9649" href="Tactic.RingSolver.html#9510" class="Bound">variables</a> <a id="9659" class="Symbol">(</a><a id="9660" href="Tactic.RingSolver.html#4760" class="Function Operator">_`⊜_</a> <a id="9665" href="Tactic.RingSolver.html#9496" class="Bound">`ring</a> <a id="9671" href="Tactic.RingSolver.html#9768" class="Function">numVars</a> <a id="9679" href="Tactic.RingSolver.html#9537" class="Bound">`lhsExpr</a> <a id="9688" href="Tactic.RingSolver.html#9560" class="Bound">`rhsExpr</a><a id="9696" class="Symbol">))</a>
                    <a id="9719" class="Symbol">(</a><a id="9720" href="Reflection.AST.Term.html#3396" class="Function">prependHLams</a> <a id="9733" href="Tactic.RingSolver.html#9510" class="Bound">variables</a> <a id="9743" class="Symbol">(</a><a id="9744" href="Tactic.RingSolver.html#3198" class="Function">`refl</a> <a id="9750" href="Tactic.RingSolver.html#9496" class="Bound">`ring</a><a id="9755" class="Symbol">))</a>
  <a id="9760" class="Keyword">where</a>
  <a id="9768" href="Tactic.RingSolver.html#9768" class="Function">numVars</a> <a id="9776" class="Symbol">:</a> <a id="9778" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
  <a id="9782" href="Tactic.RingSolver.html#9768" class="Function">numVars</a> <a id="9790" class="Symbol">=</a> <a id="9792" href="Data.List.Base.html#4879" class="Function">List.length</a> <a id="9804" href="Tactic.RingSolver.html#9510" class="Bound">variables</a>

  <a id="9817" href="Tactic.RingSolver.html#9817" class="Function">conv</a> <a id="9822" class="Symbol">:</a> <a id="9824" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="9829" class="Symbol">→</a> <a id="9831" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="9834" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="9841" href="Tactic.RingSolver.html#9817" class="Function">conv</a> <a id="9846" class="Symbol">=</a> <a id="9848" href="Tactic.RingSolver.html#5799" class="Function">convertTerm</a> <a id="9860" href="Tactic.RingSolver.html#9496" class="Bound">`ring</a> <a id="9866" href="Tactic.RingSolver.html#9768" class="Function">numVars</a> <a id="9874" href="Tactic.RingSolver.html#9502" class="Bound">opNames</a> <a id="9882" class="Symbol">(</a><a id="9883" href="Tactic.RingSolver.html#9267" class="Function">quantifiedVarMap</a> <a id="9900" href="Tactic.RingSolver.html#9768" class="Function">numVars</a><a id="9907" class="Symbol">)</a>

<a id="9910" class="Comment">-- This is the main macro which solves for equations in which the</a>
<a id="9976" class="Comment">-- variables are universally quantified over:</a>
<a id="10022" class="Comment">--</a>
<a id="10025" class="Comment">--   lemma : ∀ x y → x + y ≈ y + x</a>
<a id="10060" class="Comment">--   lemma = solve-∀ ring</a>
<a id="10086" class="Comment">--</a>
<a id="10089" class="Comment">-- where ring is your implementation of AlmostCommutativeRing.</a>
<a id="10152" class="Comment">-- (Find some example implementations in</a>
<a id="10193" class="Comment">-- Polynomial.Solver.Ring.AlmostCommutativeRing.Instances).</a>
<a id="solve-∀-macro"></a><a id="10253" href="Tactic.RingSolver.html#10253" class="Function">solve-∀-macro</a> <a id="10267" class="Symbol">:</a> <a id="10269" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="10274" class="Symbol">→</a> <a id="10276" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10281" class="Symbol">→</a> <a id="10283" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="10286" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="10288" href="Tactic.RingSolver.html#10253" class="Function">solve-∀-macro</a> <a id="10302" href="Tactic.RingSolver.html#10302" class="Bound">ring</a> <a id="10307" href="Tactic.RingSolver.html#10307" class="Bound">hole</a> <a id="10312" class="Symbol">=</a> <a id="10314" class="Keyword">do</a>
  <a id="10319" href="Tactic.RingSolver.html#10319" class="Bound">`ring</a> <a id="10325" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="10327" href="Tactic.RingSolver.html#2701" class="Function">checkIsRing</a> <a id="10339" class="Symbol">(</a><a id="10340" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="10344" href="Tactic.RingSolver.html#10302" class="Bound">ring</a> <a id="10349" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="10351" class="Symbol">)</a>
  <a id="10355" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="10366" href="Tactic.RingSolver.html#10366" class="Bound">operatorTerms</a> <a id="10380" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="10382" href="Tactic.RingSolver.html#3602" class="Function">getRingOperatorTerms</a> <a id="10403" href="Tactic.RingSolver.html#10319" class="Bound">`ring</a>

  <a id="10412" class="Comment">-- Obtain and sanitise the goal type</a>
  <a id="10451" href="Tactic.RingSolver.html#10451" class="Bound">`hole</a> <a id="10457" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="10459" href="Agda.Builtin.Reflection.html#8494" class="Postulate">inferType</a> <a id="10469" href="Tactic.RingSolver.html#10307" class="Bound">hole</a> <a id="10474" href="Reflection.TCM.Syntax.html#667" class="Function Operator">&gt;&gt;=</a> <a id="10478" href="Agda.Builtin.Reflection.html#8609" class="Postulate">reduce</a>
  <a id="10487" class="Keyword">let</a> <a id="10491" href="Tactic.RingSolver.html#10491" class="Bound">variablesAndTypes</a> <a id="10509" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="10511" href="Tactic.RingSolver.html#10511" class="Bound">equation</a> <a id="10520" class="Symbol">=</a> <a id="10522" href="Reflection.AST.Term.html#3125" class="Function">stripPis</a> <a id="10531" href="Tactic.RingSolver.html#10451" class="Bound">`hole</a>

  <a id="10540" class="Keyword">let</a> <a id="10544" href="Tactic.RingSolver.html#10544" class="Bound">variables</a> <a id="10554" class="Symbol">=</a> <a id="10556" href="Data.List.Base.html#1563" class="Function">List.map</a> <a id="10565" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a> <a id="10571" href="Tactic.RingSolver.html#10491" class="Bound">variablesAndTypes</a>
  <a id="10591" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="10596" class="Symbol">(</a><a id="10597" href="Tactic.RingSolver.html#10597" class="Bound">lhs</a> <a id="10601" href="Data.Vec.Base.html#1106" class="InductiveConstructor Operator">∷</a> <a id="10603" href="Tactic.RingSolver.html#10603" class="Bound">rhs</a> <a id="10607" href="Data.Vec.Base.html#1106" class="InductiveConstructor Operator">∷</a> <a id="10609" href="Data.Vec.Base.html#1087" class="InductiveConstructor">[]</a><a id="10611" class="Symbol">)</a> <a id="10613" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="10615" href="Reflection.TCM.Syntax.html#508" class="Function">pure</a> <a id="10620" class="Symbol">(</a><a id="10621" href="Tactic.RingSolver.html#1796" class="Function">getVisibleArgs</a> <a id="10636" class="Number">2</a> <a id="10638" href="Tactic.RingSolver.html#10511" class="Bound">equation</a><a id="10646" class="Symbol">)</a>
    <a id="10652" class="Keyword">where</a> <a id="10658" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="10666" class="Symbol">→</a> <a id="10668" href="Tactic.RingSolver.html#9008" class="Function">malformedForallTypeError</a> <a id="10693" href="Tactic.RingSolver.html#10451" class="Bound">`hole</a>

  <a id="10702" href="Tactic.RingSolver.html#10702" class="Bound">solverCall</a> <a id="10713" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="10715" href="Tactic.RingSolver.html#9387" class="Function">constructCallToSolver</a> <a id="10737" href="Tactic.RingSolver.html#10319" class="Bound">`ring</a> <a id="10743" href="Tactic.RingSolver.html#10366" class="Bound">operatorTerms</a> <a id="10757" href="Tactic.RingSolver.html#10544" class="Bound">variables</a> <a id="10767" href="Tactic.RingSolver.html#10597" class="Bound">lhs</a> <a id="10771" href="Tactic.RingSolver.html#10603" class="Bound">rhs</a>
  <a id="10777" href="Agda.Builtin.Reflection.html#8391" class="Postulate">unify</a> <a id="10783" href="Tactic.RingSolver.html#10307" class="Bound">hole</a> <a id="10788" href="Tactic.RingSolver.html#10702" class="Bound">solverCall</a>

<a id="10800" class="Keyword">macro</a>
  <a id="solve-∀"></a><a id="10808" href="Tactic.RingSolver.html#10808" class="Function">solve-∀</a> <a id="10816" class="Symbol">:</a> <a id="10818" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="10823" class="Symbol">→</a> <a id="10825" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="10830" class="Symbol">→</a> <a id="10832" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="10835" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="10839" href="Tactic.RingSolver.html#10808" class="Function">solve-∀</a> <a id="10847" class="Symbol">=</a> <a id="10849" href="Tactic.RingSolver.html#10253" class="Function">solve-∀-macro</a>

<a id="10864" class="Comment">------------------------------------------------------------------------</a>
<a id="10937" class="Comment">-- Unquantified macro</a>

<a id="malformedArgumentListError"></a><a id="10960" href="Tactic.RingSolver.html#10960" class="Function">malformedArgumentListError</a> <a id="10987" class="Symbol">:</a> <a id="10989" class="Symbol">∀</a> <a id="10991" class="Symbol">{</a><a id="10992" href="Tactic.RingSolver.html#10992" class="Bound">a</a><a id="10993" class="Symbol">}</a> <a id="10995" class="Symbol">{</a><a id="10996" href="Tactic.RingSolver.html#10996" class="Bound">A</a> <a id="10998" class="Symbol">:</a> <a id="11000" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="11004" href="Tactic.RingSolver.html#10992" class="Bound">a</a><a id="11005" class="Symbol">}</a> <a id="11007" class="Symbol">→</a> <a id="11009" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11014" class="Symbol">→</a> <a id="11016" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11019" href="Tactic.RingSolver.html#10996" class="Bound">A</a>
<a id="11021" href="Tactic.RingSolver.html#10960" class="Function">malformedArgumentListError</a> <a id="11048" href="Tactic.RingSolver.html#11048" class="Bound">found</a> <a id="11054" class="Symbol">=</a> <a id="11056" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="11068" class="Symbol">(</a> <a id="11070" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11077" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11106" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11108" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11115" class="String">&quot;First argument should be a list of free variables.&quot;</a>
  <a id="11170" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11172" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11179" class="String">&quot;Instead: &quot;</a>
  <a id="11193" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11195" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11203" href="Tactic.RingSolver.html#11048" class="Bound">found</a>
  <a id="11211" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11213" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="11215" class="Symbol">)</a>

<a id="malformedGoalError"></a><a id="11218" href="Tactic.RingSolver.html#11218" class="Function">malformedGoalError</a> <a id="11237" class="Symbol">:</a> <a id="11239" class="Symbol">∀</a> <a id="11241" class="Symbol">{</a><a id="11242" href="Tactic.RingSolver.html#11242" class="Bound">a</a><a id="11243" class="Symbol">}</a> <a id="11245" class="Symbol">{</a><a id="11246" href="Tactic.RingSolver.html#11246" class="Bound">A</a> <a id="11248" class="Symbol">:</a> <a id="11250" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="11254" href="Tactic.RingSolver.html#11242" class="Bound">a</a><a id="11255" class="Symbol">}</a> <a id="11257" class="Symbol">→</a> <a id="11259" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11264" class="Symbol">→</a> <a id="11266" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11269" href="Tactic.RingSolver.html#11246" class="Bound">A</a>
<a id="11271" href="Tactic.RingSolver.html#11218" class="Function">malformedGoalError</a> <a id="11290" href="Tactic.RingSolver.html#11290" class="Bound">found</a> <a id="11296" class="Symbol">=</a> <a id="11298" href="Agda.Builtin.Reflection.html#8431" class="Postulate">typeError</a>
  <a id="11310" class="Symbol">(</a> <a id="11312" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11319" class="String">&quot;Malformed call to solve.&quot;</a>
  <a id="11348" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11350" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11357" class="String">&quot;Goal type should be of the form: LHS ≈ RHS&quot;</a>
  <a id="11404" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11406" href="Agda.Builtin.Reflection.html#7917" class="InductiveConstructor">strErr</a> <a id="11413" class="String">&quot;Instead: &quot;</a>
  <a id="11427" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11429" href="Agda.Builtin.Reflection.html#7948" class="InductiveConstructor">termErr</a> <a id="11437" href="Tactic.RingSolver.html#11290" class="Bound">found</a>
  <a id="11445" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="11447" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="11449" class="Symbol">)</a>

<a id="checkIsListOfVariables"></a><a id="11452" href="Tactic.RingSolver.html#11452" class="Function">checkIsListOfVariables</a> <a id="11475" class="Symbol">:</a> <a id="11477" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11482" class="Symbol">→</a> <a id="11484" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11489" class="Symbol">→</a> <a id="11491" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11494" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="11499" href="Tactic.RingSolver.html#11452" class="Function">checkIsListOfVariables</a> <a id="11522" href="Tactic.RingSolver.html#11522" class="Bound">`ring</a> <a id="11528" href="Tactic.RingSolver.html#11528" class="Bound">`xs</a> <a id="11532" class="Symbol">=</a> <a id="11534" href="Agda.Builtin.Reflection.html#8530" class="Postulate">checkType</a> <a id="11544" href="Tactic.RingSolver.html#11528" class="Bound">`xs</a> <a id="11548" class="Symbol">(</a><a id="11549" href="Data.List.Reflection.html#462" class="Function">`List</a> <a id="11555" class="Symbol">(</a><a id="11556" href="Tactic.RingSolver.html#3146" class="Function">`Carrier</a> <a id="11565" href="Tactic.RingSolver.html#11522" class="Bound">`ring</a><a id="11570" class="Symbol">))</a> <a id="11573" href="Reflection.TCM.Syntax.html#667" class="Function Operator">&gt;&gt;=</a> <a id="11577" href="Agda.Builtin.Reflection.html#8573" class="Postulate">normalise</a>

<a id="11588" class="Comment">-- Extracts the deBruijn indices from a list of variables</a>
<a id="getVariableIndices"></a><a id="11646" href="Tactic.RingSolver.html#11646" class="Function">getVariableIndices</a> <a id="11665" class="Symbol">:</a> <a id="11667" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11672" class="Symbol">→</a> <a id="11674" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="11680" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
<a id="11687" href="Tactic.RingSolver.html#11646" class="Function">getVariableIndices</a> <a id="11706" class="Symbol">=</a> <a id="11708" href="Tactic.RingSolver.html#11724" class="Function">go</a> <a id="11711" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="11716" class="Keyword">where</a>
  <a id="11724" href="Tactic.RingSolver.html#11724" class="Function">go</a> <a id="11727" class="Symbol">:</a> <a id="11729" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="11736" class="Symbol">→</a> <a id="11738" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11743" class="Symbol">→</a> <a id="11745" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a> <a id="11751" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a>
  <a id="11760" href="Tactic.RingSolver.html#11724" class="Function">go</a> <a id="11763" href="Tactic.RingSolver.html#11763" class="Bound">t</a> <a id="11765" class="Symbol">(</a><a id="11766" href="Agda.Builtin.Reflection.html#4790" class="InductiveConstructor">var</a> <a id="11770" href="Tactic.RingSolver.html#11770" class="Bound">i</a> <a id="11772" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="11775" href="Data.List.Reflection.html#956" class="InductiveConstructor Operator">`∷`</a> <a id="11779" href="Tactic.RingSolver.html#11779" class="Bound">xs</a><a id="11781" class="Symbol">)</a> <a id="11783" class="Symbol">=</a> <a id="11785" href="Tactic.RingSolver.html#11724" class="Function">go</a> <a id="11788" class="Symbol">(</a><a id="11789" href="Tactic.RingSolver.Core.NatSet.html#2233" class="Function">insert</a> <a id="11796" href="Tactic.RingSolver.html#11770" class="Bound">i</a> <a id="11798" href="Tactic.RingSolver.html#11763" class="Bound">t</a><a id="11799" class="Symbol">)</a> <a id="11801" href="Tactic.RingSolver.html#11779" class="Bound">xs</a>
  <a id="11806" href="Tactic.RingSolver.html#11724" class="Function">go</a> <a id="11809" href="Tactic.RingSolver.html#11809" class="Bound">t</a> <a id="11811" href="Data.List.Reflection.html#912" class="InductiveConstructor">`[]`</a>              <a id="11829" class="Symbol">=</a> <a id="11831" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="11836" href="Tactic.RingSolver.html#11809" class="Bound">t</a>
  <a id="11840" href="Tactic.RingSolver.html#11724" class="CatchallClause Function">go</a><a id="11842" class="CatchallClause"> </a><a id="11843" class="CatchallClause Symbol">_</a><a id="11844" class="CatchallClause"> </a><a id="11845" class="CatchallClause Symbol">_</a>                 <a id="11863" class="Symbol">=</a> <a id="11865" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a>

<a id="constructSolution"></a><a id="11874" href="Tactic.RingSolver.html#11874" class="Function">constructSolution</a> <a id="11892" class="Symbol">:</a> <a id="11894" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11899" class="Symbol">→</a> <a id="11901" href="Tactic.RingSolver.html#2591" class="Record">RingOperatorTerms</a> <a id="11919" class="Symbol">→</a> <a id="11921" href="Tactic.RingSolver.Core.NatSet.html#2116" class="Function">NatSet</a> <a id="11928" class="Symbol">→</a> <a id="11930" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11935" class="Symbol">→</a> <a id="11937" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="11942" class="Symbol">→</a> <a id="11944" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="11947" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
<a id="11952" href="Tactic.RingSolver.html#11874" class="Function">constructSolution</a> <a id="11970" href="Tactic.RingSolver.html#11970" class="Bound">`ring</a> <a id="11976" href="Tactic.RingSolver.html#11976" class="Bound">opTerms</a> <a id="11984" href="Tactic.RingSolver.html#11984" class="Bound">variables</a> <a id="11994" href="Tactic.RingSolver.html#11994" class="Bound">`lhs</a> <a id="11999" href="Tactic.RingSolver.html#11999" class="Bound">`rhs</a> <a id="12004" class="Symbol">=</a> <a id="12006" class="Keyword">do</a>
  <a id="12011" href="Tactic.RingSolver.html#12011" class="Bound">`lhsExpr</a> <a id="12020" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="12022" href="Tactic.RingSolver.html#12297" class="Function">conv</a> <a id="12027" href="Tactic.RingSolver.html#11994" class="Bound">`lhs</a>
  <a id="12034" href="Tactic.RingSolver.html#12034" class="Bound">`rhsExpr</a> <a id="12043" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="12045" href="Tactic.RingSolver.html#12297" class="Function">conv</a> <a id="12050" href="Tactic.RingSolver.html#11999" class="Bound">`rhs</a>
  <a id="12057" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="12064" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="12066" href="Tactic.RingSolver.html#3318" class="Function">`trans</a> <a id="12073" href="Tactic.RingSolver.html#11970" class="Bound">`ring</a> <a id="12079" class="Symbol">(</a><a id="12080" href="Tactic.RingSolver.html#3250" class="Function">`sym</a> <a id="12085" href="Tactic.RingSolver.html#11970" class="Bound">`ring</a> <a id="12091" href="Tactic.RingSolver.html#12011" class="Bound">`lhsExpr</a><a id="12099" class="Symbol">)</a> <a id="12101" href="Tactic.RingSolver.html#12034" class="Bound">`rhsExpr</a>
  <a id="12112" class="Keyword">where</a>
  <a id="12120" href="Tactic.RingSolver.html#12120" class="Function">numVars</a> <a id="12128" class="Symbol">=</a> <a id="12130" href="Data.List.Base.html#4879" class="Function">List.length</a> <a id="12142" href="Tactic.RingSolver.html#11984" class="Bound">variables</a>

  <a id="12155" href="Tactic.RingSolver.html#12155" class="Function">varMap</a> <a id="12162" class="Symbol">:</a> <a id="12164" href="Tactic.RingSolver.html#1613" class="Function">VarMap</a>
  <a id="12173" href="Tactic.RingSolver.html#12155" class="Function">varMap</a> <a id="12180" href="Tactic.RingSolver.html#12180" class="Bound">i</a> <a id="12182" class="Symbol">=</a> <a id="12184" href="Data.Maybe.Base.html#2020" class="Function">Maybe.map</a> <a id="12194" class="Symbol">(λ</a> <a id="12197" href="Tactic.RingSolver.html#12197" class="Bound">x</a> <a id="12199" class="Symbol">→</a> <a id="12201" href="Tactic.RingSolver.html#4709" class="Function">`I</a> <a id="12204" href="Tactic.RingSolver.html#11970" class="Bound">`ring</a> <a id="12210" href="Tactic.RingSolver.html#12120" class="Function">numVars</a> <a id="12218" class="Symbol">(</a><a id="12219" href="Data.Nat.Reflection.html#719" class="Function">toFinTerm</a> <a id="12229" href="Tactic.RingSolver.html#12197" class="Bound">x</a><a id="12230" class="Symbol">))</a> <a id="12233" class="Symbol">(</a><a id="12234" href="Tactic.RingSolver.Core.NatSet.html#2881" class="Function">lookup</a> <a id="12241" href="Tactic.RingSolver.html#12180" class="Bound">i</a> <a id="12243" href="Tactic.RingSolver.html#11984" class="Bound">variables</a><a id="12252" class="Symbol">)</a>

  <a id="12257" href="Tactic.RingSolver.html#12257" class="Function">ρ</a> <a id="12259" class="Symbol">:</a> <a id="12261" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a>
  <a id="12268" href="Tactic.RingSolver.html#12257" class="Function">ρ</a> <a id="12270" class="Symbol">=</a> <a id="12272" href="Tactic.RingSolver.html#2223" class="Function">curriedTerm</a> <a id="12284" href="Tactic.RingSolver.html#11984" class="Bound">variables</a>

  <a id="12297" href="Tactic.RingSolver.html#12297" class="Function">conv</a> <a id="12302" class="Symbol">=</a> <a id="12304" class="Symbol">λ</a> <a id="12306" href="Tactic.RingSolver.html#12306" class="Bound">t</a> <a id="12308" class="Symbol">→</a> <a id="12310" class="Keyword">do</a>
    <a id="12317" href="Tactic.RingSolver.html#12317" class="Bound">t&#39;</a> <a id="12320" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="12322" href="Tactic.RingSolver.html#5799" class="Function">convertTerm</a> <a id="12334" href="Tactic.RingSolver.html#11970" class="Bound">`ring</a> <a id="12340" href="Tactic.RingSolver.html#12120" class="Function">numVars</a> <a id="12348" href="Tactic.RingSolver.html#11976" class="Bound">opTerms</a> <a id="12356" href="Tactic.RingSolver.html#12155" class="Function">varMap</a> <a id="12363" href="Tactic.RingSolver.html#12306" class="Bound">t</a>
    <a id="12369" href="Reflection.TCM.html#1016" class="Postulate">return</a> <a id="12376" href="Function.Base.html#1994" class="Function Operator">$</a> <a id="12378" href="Tactic.RingSolver.html#4854" class="Function">`correct</a> <a id="12387" href="Tactic.RingSolver.html#11970" class="Bound">`ring</a> <a id="12393" href="Tactic.RingSolver.html#12120" class="Function">numVars</a> <a id="12401" href="Tactic.RingSolver.html#12317" class="Bound">t&#39;</a> <a id="12404" href="Tactic.RingSolver.html#12257" class="Function">ρ</a>

<a id="12407" class="Comment">-- Use this macro when you want to solve something *under* a lambda. For example:</a>
<a id="12489" class="Comment">-- say you have a long proof, and you just want the solver to deal with an</a>
<a id="12564" class="Comment">-- intermediate step. Call it like so:</a>
<a id="12603" class="Comment">--</a>
<a id="12606" class="Comment">--   lemma₃ : ∀ x y → x + y * 1 + 3 ≈ 2 + 1 + y + x</a>
<a id="12658" class="Comment">--   lemma₃ x y = begin</a>
<a id="12682" class="Comment">--     x + y * 1 + 3 ≈⟨ +-comm x (y * 1) ⟨ +-cong ⟩ refl ⟩</a>
<a id="12741" class="Comment">--     y * 1 + x + 3 ≈⟨ solve (x ∷ y ∷ []) Int.ring ⟩</a>
<a id="12795" class="Comment">--     3 + y + x     ≡⟨ refl ⟩</a>
<a id="12826" class="Comment">--     2 + 1 + y + x ∎</a>
<a id="12849" class="Comment">--</a>
<a id="12852" class="Comment">-- The first argument is the free variables, and the second is the</a>
<a id="12919" class="Comment">-- ring implementation (as before).</a>
<a id="solve-macro"></a><a id="12955" href="Tactic.RingSolver.html#12955" class="Function">solve-macro</a> <a id="12967" class="Symbol">:</a> <a id="12969" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="12974" class="Symbol">→</a> <a id="12976" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="12981" class="Symbol">→</a> <a id="12983" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="12988" class="Symbol">→</a> <a id="12990" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="12993" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="12995" href="Tactic.RingSolver.html#12955" class="Function">solve-macro</a> <a id="13007" href="Tactic.RingSolver.html#13007" class="Bound">variables</a> <a id="13017" href="Tactic.RingSolver.html#13017" class="Bound">ring</a> <a id="13022" href="Tactic.RingSolver.html#13022" class="Bound">hole</a> <a id="13027" class="Symbol">=</a> <a id="13029" class="Keyword">do</a>
  <a id="13034" href="Tactic.RingSolver.html#13034" class="Bound">`ring</a> <a id="13040" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13042" href="Tactic.RingSolver.html#2701" class="Function">checkIsRing</a> <a id="13054" class="Symbol">(</a><a id="13055" href="Agda.Builtin.Reflection.html#4903" class="InductiveConstructor">def</a> <a id="13059" href="Tactic.RingSolver.html#13017" class="Bound">ring</a> <a id="13064" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="13066" class="Symbol">)</a>
  <a id="13070" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="13081" href="Tactic.RingSolver.html#13081" class="Bound">operatorTerms</a> <a id="13095" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13097" href="Tactic.RingSolver.html#3602" class="Function">getRingOperatorTerms</a> <a id="13118" href="Tactic.RingSolver.html#13034" class="Bound">`ring</a>

  <a id="13127" class="Comment">-- Obtain and sanitise the list of variables</a>
  <a id="13174" href="Tactic.RingSolver.html#13174" class="Bound">listOfVariables′</a> <a id="13191" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13193" href="Tactic.RingSolver.html#11452" class="Function">checkIsListOfVariables</a> <a id="13216" href="Tactic.RingSolver.html#13034" class="Bound">`ring</a> <a id="13222" href="Tactic.RingSolver.html#13007" class="Bound">variables</a>
  <a id="13234" href="Agda.Builtin.Reflection.html#9340" class="Postulate">commitTC</a>
  <a id="13245" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="13250" href="Tactic.RingSolver.html#13250" class="Bound">variableIndices</a> <a id="13266" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13268" href="Reflection.TCM.Syntax.html#508" class="Function">pure</a> <a id="13273" class="Symbol">(</a><a id="13274" href="Tactic.RingSolver.html#11646" class="Function">getVariableIndices</a> <a id="13293" href="Tactic.RingSolver.html#13174" class="Bound">listOfVariables′</a><a id="13309" class="Symbol">)</a>
    <a id="13315" class="Keyword">where</a> <a id="13321" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="13329" class="Symbol">→</a> <a id="13331" href="Tactic.RingSolver.html#10960" class="Function">malformedArgumentListError</a> <a id="13358" href="Tactic.RingSolver.html#13174" class="Bound">listOfVariables′</a>

  <a id="13378" class="Comment">-- Obtain and santise the goal type</a>
  <a id="13416" href="Tactic.RingSolver.html#13416" class="Bound">hole′</a> <a id="13422" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13424" href="Agda.Builtin.Reflection.html#8494" class="Postulate">inferType</a> <a id="13434" href="Tactic.RingSolver.html#13022" class="Bound">hole</a> <a id="13439" href="Reflection.TCM.Syntax.html#667" class="Function Operator">&gt;&gt;=</a> <a id="13443" href="Agda.Builtin.Reflection.html#8609" class="Postulate">reduce</a>
  <a id="13452" href="Agda.Builtin.Maybe.html#174" class="InductiveConstructor">just</a> <a id="13457" class="Symbol">(</a><a id="13458" href="Tactic.RingSolver.html#13458" class="Bound">lhs</a> <a id="13462" href="Data.Vec.Base.html#1106" class="InductiveConstructor Operator">∷</a> <a id="13464" href="Tactic.RingSolver.html#13464" class="Bound">rhs</a> <a id="13468" href="Data.Vec.Base.html#1106" class="InductiveConstructor Operator">∷</a> <a id="13470" href="Data.Vec.Base.html#1087" class="InductiveConstructor">[]</a><a id="13472" class="Symbol">)</a> <a id="13474" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13476" href="Reflection.TCM.Syntax.html#508" class="Function">pure</a> <a id="13481" class="Symbol">(</a><a id="13482" href="Tactic.RingSolver.html#1796" class="Function">getVisibleArgs</a> <a id="13497" class="Number">2</a> <a id="13499" href="Tactic.RingSolver.html#13416" class="Bound">hole′</a><a id="13504" class="Symbol">)</a>
    <a id="13510" class="Keyword">where</a> <a id="13516" href="Agda.Builtin.Maybe.html#195" class="InductiveConstructor">nothing</a> <a id="13524" class="Symbol">→</a> <a id="13526" href="Tactic.RingSolver.html#11218" class="Function">malformedGoalError</a> <a id="13545" href="Tactic.RingSolver.html#13416" class="Bound">hole′</a>

  <a id="13554" href="Tactic.RingSolver.html#13554" class="Bound">solution</a> <a id="13563" href="Reflection.TCM.Syntax.html#667" class="Function Operator">←</a> <a id="13565" href="Tactic.RingSolver.html#11874" class="Function">constructSolution</a> <a id="13583" href="Tactic.RingSolver.html#13034" class="Bound">`ring</a> <a id="13589" href="Tactic.RingSolver.html#13081" class="Bound">operatorTerms</a> <a id="13603" href="Tactic.RingSolver.html#13250" class="Bound">variableIndices</a> <a id="13619" href="Tactic.RingSolver.html#13458" class="Bound">lhs</a> <a id="13623" href="Tactic.RingSolver.html#13464" class="Bound">rhs</a>
  <a id="13629" href="Agda.Builtin.Reflection.html#8391" class="Postulate">unify</a> <a id="13635" href="Tactic.RingSolver.html#13022" class="Bound">hole</a> <a id="13640" href="Tactic.RingSolver.html#13554" class="Bound">solution</a>

<a id="13650" class="Keyword">macro</a>
  <a id="solve"></a><a id="13658" href="Tactic.RingSolver.html#13658" class="Function">solve</a> <a id="13664" class="Symbol">:</a> <a id="13666" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="13671" class="Symbol">→</a> <a id="13673" href="Agda.Builtin.Reflection.html#489" class="Postulate">Name</a> <a id="13678" class="Symbol">→</a> <a id="13680" href="Agda.Builtin.Reflection.html#4688" class="Datatype">Term</a> <a id="13685" class="Symbol">→</a> <a id="13687" href="Agda.Builtin.Reflection.html#8218" class="Postulate">TC</a> <a id="13690" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
  <a id="13694" href="Tactic.RingSolver.html#13658" class="Function">solve</a> <a id="13700" class="Symbol">=</a> <a id="13702" href="Tactic.RingSolver.html#12955" class="Function">solve-macro</a>
</pre></body></html>